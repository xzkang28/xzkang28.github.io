```
title: K近邻算法
date: 2017-03-28 22:55:13
desc: 机器学习实战-k近邻算法(knn)
---
```

k近邻算法是一个分类算法，比如我们可以根据电影的打斗镜头和接吻镜头相应的数量来判断电影是动作片还是爱情片。

k近邻算法的工作原理是：存在一个数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本中特征最相似数据（最临近）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。

回到电影分类的例子，假如我有一部电影已知它的打斗镜头和接吻镜头，那我们怎么根据样本集来判断呢？

| 电影名称                        | 打斗镜头 | 接吻镜头 | 电影类型 |
| --------------------------- | ---- | ---- | ---- |
| California Man              | 3    | 104  | 爱情片  |
| He 's Not Really into Dudes | 2    | 100  | 爱情片  |
| Beautiful Woman             | 1    | 81   | 爱情片  |
| Kevin Longblade             | 101  | 10   | 动作片  |
| Robo Slayer                 | 99   | 5    | 动作片  |
| Amped II                    | 98   | 2    | 动作片  |
| ?                           | 18   | 90   | 未知   |

我们可以把数据抽象为一个向量（或者看成坐标点），比如California Man的数据就可以抽象成(3,104)；那如何计算两部电影之间的相似性呢？在这里我们可以使用欧式距离公式来计算两个向量点之间的距离：
$$
d=\sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2}
$$
那未知电影与California Man之间的距离计算为：
$$
d=\sqrt{(18-3)^2+(90-104)^2}=20.5
$$
同理，其他电影与未知电影之间的距离也可以计算，最后按距离递增排序：

| 电影名称                        | 与未知电影的距离 |
| --------------------------- | -------- |
| California Man              | 20.5     |
| He 's Not Really into Dudes | 18.7     |
| Beautiful Woman             | 19.2     |
| Kevin Longblade             | 115.3    |
| Robo Slayer                 | 117.4    |
| Amped II                    | 118.9    |

如果我们假定k=3，则最靠近的电影依次是California Man、He 's Not Really into Dudes和Beautiful Woman。k-近邻算法按照距离最接近的三部电影来决定未知电影的类型，而这三部全部都是爱情片，因此我们判断未知电影也是爱情片。

接下来上knn算法的代码代码是python，需要导入numpy第三方包：

```python
def classify0(inX,dataSet,labels,k):
	dataSetSize = dataSet.shape[0]					//取矩阵的列数
	diffMat = tile(inX,(dataSetSize,1))-dataSet		//建立未知电影的矩阵，并减去样本矩阵
	sqDiffMat = diffMat**2							
	sqDistances = sqDiffMat.sum(axis=1)				
	disatances = sqDistances**0.5					//计算欧式距离
	sortedDistIndicies = disatances.argsort()		//递增排序
	classCount={}
	for i in range(k):								//对前k个数据的类别计数，返回出现次数最多的类别
		voteIlabel = labels[sortedDistIndicies[i]]
		classCount[voteIlabel] = classCount.get(voteIlabel,0)+1
	sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True)
	print classCount,sortedClassCount
	return sortedClassCount[0][0]
```

classify0() 函数有4个输入参数：用于分类的输入向量是inX，输入的训练样本集为dataSet，标签向量为labels（爱情片抽象为1，动作片抽象为0），最后的参数k表示用于选择最近邻居的数目，其中标签向量的元素数目和矩阵dataSet的行数相同。

为了更好理解，我把例子中的输入的参数也贴出来：
$$
inX=\begin{bmatrix}
        18 & 90 \\
        \end{bmatrix}
        ,dataSet=\begin{bmatrix}
        3 & 104 \\
        2 & 100 \\
        1 & 81 \\
        101 & 10 \\
        99 & 5 \\
        98 & 2 \\
        \end{bmatrix}
        ,labels=\begin{bmatrix}
        1 \\
        1 \\
        1 \\
        0 \\
        0 \\
        0 \\
        \end{bmatrix}
$$




我们已经成功使用k-近邻算法构造了一个分类器，想想看分类器一定是正确的吗？答案是否定的，分类器并不会得到百分百正确的结果，因为分类器还会受到多种因素的影响，比如数据集和k值的变化就可能产生不同的结果；我们可以多种方法来检测分类器的准确率。

接下来我们用一个实际的案例来演示完整的分类器，图像识别是机器学习领域的一个典型应用，其本质原理是把图像转化为电脑能够识别的二进制文件，再通过复杂的分类算法来识别图像，在这里我们先尝试用一个简化版数据集来实践，假设我们有一批处理后的样本集，其中一个文件如下，它的分类是数字3：

![mark](http://om2zpy4xm.bkt.clouddn.com/blog/20170328/222305843.png)

那么如何去识别一个新的数字呢？接下来上代码：

```python
def img2vector(filename):							//根据样本创建一个1行1024列的训练矩阵
	returnVect = zeros((1,1024))
	fr = open(filename)
	for i in range(32):
		lineStr = fr.readline()
		for j in range(32):
			returnVect[0,32*i+j] = int(lineStr[j])
	return returnVect

def handwritingClassTest():						
	hwLabels = []
	traningFileList = listdir('trainingDigits')		//根据样本创建一个m行1024列的训练矩阵
	m = len(traningFileList)
	traningMat = zeros((m,1024))
	for i in range(m):								//根据文件名解析出分类数字
		fileNameStr = traningFileList[i]
		fileStr = fileNameStr.split('.')[0]
		classNumStr = int(fileStr.split('_')[0])
		hwLabels.append(classNumStr)
		traningMat[i,:] = img2vector('trainingDigits/%s'%fileNameStr)
	testFileList = listdir('testDigits')
	errorCount = 0.0
	mTest = len(testFileList)
	for i in range(mTest):							//用测试集来计算分类器的准确率
		fileNameStr = testFileList[i]
		fileStr = fileNameStr.split('.')[0]
		classNumStr = int(fileStr.split('_')[0])
		vectorUnderTest = img2vector('testDigits/%s'%fileNameStr)
		classifierResult = classify0(vectorUnderTest,traningMat,hwLabels,3)
		print"the classfifier came back with: %d,the real answer is :%d"%(classifierResult,classNumStr)
		if(classifierResult != classNumStr):errorCount += 1.0
	print "\nthe total number of errors is: %d"%errorCount
	print "\nthe total error rate is %f"%(errorCount/float(mTest))
```

因为数据集是txt文件，每一个文件名格式都是 3_7.txt，其中3是该样本的实际分类，7是该样本在3分类下的id，分类器先把trainingDigits目录下的所有样本集转成1024维的训练矩阵，再把testDigits目录下的所有测试集也转成1024维的矩阵，再用之前的classify0() 函数来分类，最后再对比分类器分类结果和实际分类，以此来计算分类器的准确率。

最后总结一下，knn近邻算法就像是“近朱者赤，近墨者黑”，如果一部电影的打斗镜头和接吻镜头与另外k部接近，knn近邻算法就会判断这部电影属于另外k部电影中占多数的类型。

[本文的数据集和代码下载>>](http://download.csdn.net/detail/u012491566/6474803)









