<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zikang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zikang.me/"/>
  <updated>2018-08-05T11:21:08.009Z</updated>
  <id>http://zikang.me/</id>
  
  <author>
    <name>子康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《数据化管理》读书笔记</title>
    <link href="http://zikang.me/2018/08/05/20180805-%E3%80%8A%E6%95%B0%E6%8D%AE%E5%8C%96%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zikang.me/2018/08/05/20180805-《数据化管理》读书笔记/</id>
    <published>2018-08-05T09:47:13.000Z</published>
    <updated>2018-08-05T11:21:08.009Z</updated>
    
    <content type="html"><![CDATA[<p>《数据化管理》读书笔记</p><a id="more"></a><p>我理解数据在一家公司中所起的作用就类似于一面镜子，能够客观地反映一家企业的运营状况，建立良好的数据管理体系能够有效地帮助企业提升效率，数据和业务是相辅相成的，业务生产数据，数据驱动增长；最近有时间抽空看了《数据化管理》这本书，内容简单易懂偏入门适合新人阅读，作者提到的数据分析方法论和零售/电商行业数据体系在日常工作中大多有接触过，本篇读书笔记仅筛选书中对我有用的内容进行总结和梳理，供参考。</p><p>一、权重指数</p><p>权重指数主要是为了相对公平的比较一个指标，排除一些内在外在因素干扰，比如节假日、促销等等，比较核心的指标有：</p><p>日权重指数：平均销售额最低的一天为1，分别用该自然周其余六天的平均日销售额除以该最低值</p><p>周权重指数：日权重指数相加</p><p>单位权重=总销售额/总权重指数</p><p>单位权重曲线可以评估特殊事件的影响，比如评估某促销活动对于日常销售的影响可以通过对活动前的单位权重平均值和活动中及活动后的单位权重平均值做对比，介绍两个指标：</p><p>促销爆发度=（促销期间的平均权重销售额-促销前的平均权重销售额）/促销前的平均权重销售额*100%</p><p>促销衰减度=（促销期间的平均权重销售额-促销后的平均权重销售额）/促销前的平均权重销售额*100%</p><p>促销爆发度越高说明活动效果明显，促销衰减度越低说明活动带来的持续效果越好</p><p>促销的程度可以量化分级，级别越高，活动当天的日权重指数放大倍数越高，在预测效率时相应的日权重指数时需要做系数放大</p><p>二、销售管理</p><p>2.1销售管理是对商品销售层面的数据管理，销售管理中的目标管理需要遵循SMART原则：</p><p>Specific：具体明确，同一目标最好具有唯一性</p><p>Measurable：可量化，不能量化的目标没有追踪的意义</p><p>Attainable：可实现的</p><p>Realistic：相关性</p><p>Time bound：时限性</p><p>2.2销售管理的数据分析可以从零售行业的人、货、场三个角度进行分析：</p><p>人：员工、顾客、第三方人员</p><p>货：商品</p><p>场：平台、渠道</p><p>比如客单价下降我可以分析是不是由于老员工走了或者新员工培训不到位，是不是商品缺货或者商品品降价，是不是竞争对手有新的策略或者是货架位置不合理等等</p><p>2.3销售管理中的核心指标有：</p><p>连带率（附加值、效益比、购物篮系数、平均客件数）=该品销售的总数量/成交总订单数</p><p>连带率这个指标是为了分析商品的热度，连带率越高在一定程度上能说明该商品人气旺</p><p>相对会员流失率=某段时间流失的会员数量/期初有效会员数量*流失权重值100%</p><p>流失率权重值=流失会员的平均客单价/有效会员的平均客单价</p><p>我自己工作的公司在计算流失、留存方面就没有考虑到会员权重的特性，很明显流失一个高购买力会员比流失一个普通会员要严重的多</p><p>坪效=销售（利润）/店铺面积</p><p>人效=销售（利润）/员工数</p><p>交叉比率=商品毛利率*商品周转率</p><p>商品周转率=销售收入/((期初库存+期末库存)/2)</p><p>当指标比较多的时候可以通过矩阵对比法计算指标的权重值以确定哪些指标是重要的，这个分析思路可以用在其他需要筛选的任务上</p><p>2.4做促销分析的时候可以通过“三度”来分析：广度，促销的渠道范围；宽度，促销的品类范围；深度，促销的力度级别</p><p>三、商品管理    </p><p>3.1商品管理的数据分析可以从零售行业的进、销、存三个角度进行分析。</p><p>3.2商品的分类有两种方式：</p><p>自然分类法：线分类（父子关系）、面分类（用途、原材料、工艺、季节、产地）</p><p>销售分类法：价格（高中低）、利润（高低零负）、生命周期（导入、成长、成熟、衰退）、二八分类、ABC分类（1：2：7）、平均值分类（根据平均次数分五类甚至更多）</p><p>3.3商品价格分析的核心指标有：</p><p>价格带宽度：最高价-最低价</p><p>价格带深度：价格带中的品类或sku数</p><p>价格带广度：价格带中不重复销售价格的数量，每个不重复的价格叫做一条价格线</p><p>价格点：在价格带中最容易被顾客接受的一条价格线</p><p>价格区：价格带中包含价格点的一个顾客主要购买价格区间</p><p>价格弹性系数=销量变动比率/价格变动比率（商品价格变化1%，商品销量变化的百分比）【如果价格变化和销量变化的分析对象不是同一个，则称为交叉价格弹性系数，常用在高度竞争品，如百事和可口可乐】</p><p>3.3商品的定价策略</p><p>定价之前需要注意消费者要的不是便宜，而是占便宜</p><p>成本定价法：定价=单位成本/(1-商品毛利率)</p><p>目标利润定价法：定价=总成本*(1+目标利润率)/预计销售数量</p><p>尾数定价法：9、8结尾、不要用 4、250</p><p>弧形数字定价法：0、3、5、6、8、9为弧形数字，消费者看到之后不会有太大刺激感</p><p>奇偶数定价法：77777、88888</p><p>价格陪衬法：适当引入高价或者低价商品来衬托主力商品</p><p>定价的四个区隔原则：区隔市场（是否有竞争对手）、区隔产品（竞争对手是否卖）、区隔对象（用户对价格是否敏感）、区隔时间（平时或节假日）</p><p>3.4商品的关联度分析</p><p>支持度=同时包含AB商品的交易/总交易<em>100%</em></p><p>可信度=同时包含AB商品的交易/包含A商品的总交易*100%</p><p>提升度=可信度/商品B在总交易中出现的概率（1是提升度的一个分界值，大于1效果好）</p><p>这里的关联度分析比较简单，而实际场景会比较复杂，后续我会单独就关联度分析总结一篇新文章</p><p>3.5商品的购物篮分析</p><p>购物篮系数=某段时间商品销售总数/某段时间的购物篮总数</p><p>指定商品的购物篮系数=某段时间含指定商品购物篮的销售总数/某段时间含指定商品的购物篮总数</p><p>人气指数=某段时间含指定商品购物篮销售总数/某段时间的购物篮总数</p><p>购物篮分析主要是分析人气商品，购物篮系数和人气指数需要一起看才更加客观</p><p>3.6商品的库存分析</p><p>库存周转率=出库(销售)数量/((期初库存+期末库存)/2)【数量可以换成金额】</p><p>用出库是供应链角度，一个品可能因为退货原因出库多次</p><p>库存天数=期末库存/(某时期销售金额/天数)</p><p>售罄率=某时期销售数量/(期初库存+期中进货库存)*100%</p><p>售罄率这个指标的定义非常多，我司采用的是售罄的商品数量除总商品数量得出，一般也会结合售罄原因和时段进行分析，售罄高了损耗就会低，如何维持售罄和报损之间的平衡是供应链管理的重要课题，而这个课题的关键是准确的预测销量，举个例子，如果今天销量预测很准确，该批次采购补货的数量刚好够卖完，这样售罄率和损耗率都是0，并且收益是最大化的</p><p>四、零售数据管理</p><p>4.1渠道数据管理：对一个新市场的宏观分析常用PEST分析法：</p><p>Political：政治，政策、法规的影响及稳定性</p><p>Economic：经济，GDP、消费指数、人均工资、失业率</p><p>Social：社会，人口数量及分布、年龄结构、生活方式、购买习惯</p><p>Technology：技术，新技术发明、传播、使用</p><p>除此之外还可以采用以下量化分析方式：</p><p>连锁比率法：城市容量（年）=城市总人口数x目标顾客占比x平均年消费额</p><p>购买力指数法：首先找到和购买力有关的因素，然后计算区域占总体比重，再加权（精准度差）</p><p>区域购买力占全国比重=权重1x区域人口占全国比重+权重2x区域消费品零售额占全国比重+权重3x区域个人可支配收入占全国比重</p><p>4.2会员数据管理：</p><p>会员分类可以采用传统的RFM模型来分析，也可以按下面的优化版分析</p><p>忠诚度：最近一次的消费时间Recency、消费频率Frequency</p><p>购买力：消费金额Monetary、最大单笔消费额</p><p>价格容忍度：特价商品消费占比、高单价商品消费占比</p><p>会员购买行为分析：</p><p>5W2H分析法：What（产品）、Who（消费者）、When（时间）、Where（地点）、Why（原因）、How to（如何实现）、How much（数量）【每一项都可以打标签】</p><p>而Why可以通过分析其他4W2H得出，比如用户不愿意购买，可以分析他是不是因为不在旺季、门店位置过远、支付方式冗余、商品定价过高等等</p><p>4.3竞争对手分析：</p><p>都是传统的商业分析模型，比如：</p><p>波特竞争力分析模型：供应商的议价能力、购买者的议价能力、潜在竞争者进入的能力、替代品的替代能力、行业竞争力</p><p>SWOT分析模型：优势Strength、劣势Weakness、机会Opportunities、威胁Threats（SW是内部关键因素、OT是外部关键因素）</p><p>总结</p><p>做数据分析需要考虑全面，任何数据都是有维度和指标构成，维度是否一致包括分析对象、时间是否一致，而指标是否一致就包括计算方式、定义、数据源是否一致，只有在指标维度都一致的情况下才可以进行比较，比较的过程也要遵循对等比较的原则，比如，春节对应春节，星期几对应星期几，2月对应2月但要注意是不是都是28天等等，并且数据分析要基于业务才有价值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《数据化管理》读书笔记&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>决策树算法</title>
    <link href="http://zikang.me/2017/03/30/20170330-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <id>http://zikang.me/2017/03/30/20170330-决策树算法/</id>
    <published>2017-03-30T15:47:13.000Z</published>
    <updated>2017-03-30T15:47:18.489Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习实战-决策树算法（ID3）</p><a id="more"></a><p>决策数也是一种常见的分类方法，比如我们可以粗略地根据一种海洋生物是否能不浮出水面生存，是否有脚蹼来判断它是不是鱼类。</p><p>假设我们有一些新的数据样本，现在要对“是否属于鱼类”进行决策，那么我们通常会进行一些“子决策”：先看“不浮出水面是否可以生存”，如果可以生存，再看“是否有脚蹼”，最后得出最终决策：这属于鱼类。显然，决策过程的最终结论对应了我们所希望的判定结果“是”或者“不是”鱼类；决策过程中提出的每个判定问题都是对某个属性的“测试”，例如“不浮出水面是否可以生存？”；每个测试结果或是导出最终结论或是导出进一步的判定问题，其考虑范围是在上次决策结果的限定范围之内，例如“不浮出水面能生存”之后再判断“是否有脚蹼？“。</p><table><thead><tr><th style="text-align:center">样本id</th><th style="text-align:center">不浮出水面是否可以生存</th><th style="text-align:center">是否有脚蹼</th><th style="text-align:center">属于鱼类</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr></tbody></table><p>决策过程如下：</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170329/222735012.png" alt="mark"></p><p>决策树的原理：一颗决策树包含一个根节点、若个干内部节点和若干个叶节点；叶节点对应属性结果，其他每个节点则对应于一个属性测试；每个节点包含的样本集合根据属性测试的结果被划分到子节点中；根节点包含样本全集，从根节点到每个叶节点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一颗泛化能力强的，即处理未见示例能力强的决策树，其基本流程遵循简单的“分而治之”策略。</p><p>之前所说的knn算法可以完成很多分类任务，但是它最大的缺点就是无法给出数据的内在含义，决策树的主要优势就在于数据形式非常容易理解。</p><p>再进一步解释决策树算法之前，先介绍俩个概念：”信息熵“（也叫“香农熵”）和”信息增益“：</p><p>”信息熵“是度量样本集合纯度最常用的一种指标，假定当前样本集合D中第k类样本所占的比例为$p_k(k=1,2,…,n)$，则D的信息熵定义为：</p><p>$$<br>Ent(D)=-\sum_{k=1}^np_klog_2p_k<br>$$<br>$Ent(D)$的值越小，则D的纯度越高。</p><p>假定离散属性a有V个可能的取值{$a^1,a^2,…,a^V$},若使用a来对样本集D进行划分，则会产生V个分支节点，其中第v个分支节点包含了D中所有在属性a上取值为$a^v$的样本，记为$D^v$。我们可以根据信息熵计算公式计算出$Ent(D^v)$。再考虑到不同的分支节点所包含的样本数不同，给分支节点赋予权重$|D^v|/|D|$，即样本数越多的分支节点影响越大，于是可以计算出属性a对样本集D进行划分所得的“信息增益”<br>$$<br>Gain(D,a)=Ent(D)-\sum_{v=1}^V{|D^v|\over|D|}Ent(D^v)<br>$$<br>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大，因此，我们可以用信息增益来进行决策树的划分属性选择。</p><p>用鱼分类的数据为例，显然，分类只有“鱼类”和“非鱼类”两种，即k=2，而“鱼类”占比2/5，“非鱼类”占比3/5，于是可以求出根节点的信息熵为</p><p>$$<br>Ent(D)=-\sum_{k=1}^2p_klog_2p_k=-({2\over5}log_2{2\over5}+{3\over5}log_2{3\over5})=0.29<br>$$<br>然后我们假设以属性“不浮出水面是否能够生存”划分数据集，划分后得到两个子集$D_1{1,2,3}$和$D_2{4,5}$ ；再分别计算$D_1$和$D_2$的信息熵<br>$$<br>Ent(D_1)=-({2\over3}log_2{2\over3}+{1\over3}log_2{1\over3})=0.27<br>$$</p><p>$$<br>Ent(D_2)=-({2\over2}log_2{2\over2})=0<br>$$</p><p>于是可以计算出属性“不浮出水面是否能够生存”的信息增益为<br>$$<br>\begin{align}<br>Gain(D,不浮出水面是否能够生存)&amp;=Ent(D)-\sum_{v=1}^2{|D^v|\over|D|}Ent(D^v)\\<br>&amp;=0.29-({3\over5}\times0.27+{2\over5}\times0)=0.128<br>\end{align}<br>$$<br>同理我们也可以计算出属性“是否有脚蹼”的信息增益为<br>$$<br>Gain(D,是否有脚蹼)=0.24<br>$$<br>显然，属性“不浮出水面是否能够生存”的信息增益最大，于是它被选为划分属性。这种以信息增益作为划分准则的算法就是著名的ID3决策树算法，接下来贴完整的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span>//计算信息熵</div><div class="line">numEntries = len(dataSet)</div><div class="line">labelCounts = &#123;&#125;</div><div class="line"><span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</div><div class="line">currentLabel = featVec[<span class="number">-1</span>]</div><div class="line"><span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</div><div class="line">labelCounts[currentLabel] = <span class="number">0</span></div><div class="line">labelCounts[currentLabel] += <span class="number">1</span></div><div class="line">shannonEnt = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</div><div class="line">prob = float(labelCounts[key])/numEntries</div><div class="line">shannonEnt -= prob * log(prob,<span class="number">2</span>)</div><div class="line"><span class="keyword">return</span> shannonEnt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet,axis,value)</span>:</span>//按照给定特征划分数据集</div><div class="line">retDataSet = []</div><div class="line"><span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</div><div class="line"><span class="keyword">if</span> featVec[axis] == value:</div><div class="line">reducedFeatVec = featVec[:axis]</div><div class="line">reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</div><div class="line">retDataSet.append(reducedFeatVec)</div><div class="line"><span class="keyword">return</span> retDataSet</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span>//通过比较信息增益选择最佳划分属性</div><div class="line">numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></div><div class="line">baseEntropy = calcShannonEnt(dataSet)</div><div class="line">bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</div><div class="line">featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line">uniqueVals = set(featList)</div><div class="line">newEntropy = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</div><div class="line">subDataSet = splitDataSet(dataSet,i,value)</div><div class="line">prob = len(subDataSet)/float(len(dataSet))</div><div class="line">newEntropy += prob * calcShannonEnt(subDataSet)</div><div class="line">infoGain = baseEntropy - newEntropy</div><div class="line"><span class="keyword">if</span> (infoGain &gt; bestInfoGain):</div><div class="line">bestInfoGain = infoGain</div><div class="line">bestFeature = i</div><div class="line"><span class="keyword">return</span> bestFeature</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span>//选择出现次数最多的分类</div><div class="line">classCount = &#123;&#125;</div><div class="line"><span class="keyword">for</span> vote <span class="keyword">in</span> classList:</div><div class="line"><span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.key():classCount[vote] = <span class="number">0</span></div><div class="line">classCount[vote] += <span class="number">1</span></div><div class="line">sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet,labels)</span>:</span>//创建决策树</div><div class="line">classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line"><span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</div><div class="line"><span class="keyword">return</span> classList[<span class="number">0</span>]</div><div class="line"><span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</div><div class="line"><span class="keyword">return</span> majorityCnt(classList)</div><div class="line">bestFeat = chooseBestFeatureToSplit(dataSet)</div><div class="line">bestFeatLabel = labels[bestFeat]</div><div class="line">myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</div><div class="line"><span class="keyword">del</span>(labels[bestFeat])</div><div class="line">featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line">uniqueVals = set(featValues)</div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</div><div class="line">subLabels = labels[:]</div><div class="line">myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLabels)</div><div class="line"><span class="keyword">return</span> myTree</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree,featLabels,testVec)</span>:</span>//使用决策树执行分类</div><div class="line">firstStr = inputTree.keys()[<span class="number">0</span>]</div><div class="line">secondDict = inputTree[firstStr]</div><div class="line">featIndex = featLabels.index(firstStr)</div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</div><div class="line"><span class="keyword">if</span> testVec[featIndex] == key:</div><div class="line"><span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</div><div class="line">classLabel = classify(secondDict[key],featLabels,testVec)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">classLabel = secondDict[key]</div><div class="line"><span class="keyword">return</span> classLabel</div></pre></td></tr></table></figure><p>可以看出，ID3决策树算法是一个递归过程，而在算法种有三种情况会导致递归返回：</p><ol><li><p>当前节点包含的样本全属于同一类别，无需划分。</p></li><li><p>属性集为空，或是所有样本在所有属性上的取值相同，无法划分。</p></li><li><p>当前节点包含的样本集合为空，不能划分。</p></li></ol><p>在第2种情况下，我们把当前节点标记为叶节点，并将其类别设定为该节点样本最多的类别；在第3种情况下，同样把当前节点标记为叶节点，但将其类别设定为其父节点所含样本最多的类别，注意这两种情形的处理实质不同：情形2是在利用当前节点的后验分布，而情形3则是把父节点的样本分布作为当前节点的先验分布。</p><p>总结一下：决策树算法就是通过信息增益不断递归寻找最好的划分方式，构建树的过程就好比“开枝散叶”，当有新的分类任务时可以很快的从树的“根”到“叶”找到最终的分类结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习实战-决策树算法（ID3）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>k近邻算法</title>
    <link href="http://zikang.me/2017/03/28/20170328-k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://zikang.me/2017/03/28/20170328-k近邻算法/</id>
    <published>2017-03-28T15:49:13.000Z</published>
    <updated>2017-03-28T15:34:59.148Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习实战-k近邻算法（knn）</p><a id="more"></a><p>k近邻算法是一个分类算法，比如我们可以根据电影的打斗镜头和接吻镜头相应的数量来判断电影是动作片还是爱情片。</p><p>k近邻算法的工作原理是：存在一个数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本中特征最相似数据（最临近）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p><p>回到电影分类的例子，假如我有一部电影已知它的打斗镜头和接吻镜头，那我们怎么根据样本集来判断呢？</p><table><thead><tr><th>电影名称</th><th style="text-align:center">打斗镜头</th><th style="text-align:center">接吻镜头</th><th style="text-align:center">电影类型</th></tr></thead><tbody><tr><td>California Man</td><td style="text-align:center">3</td><td style="text-align:center">104</td><td style="text-align:center">爱情片</td></tr><tr><td>He ‘s Not Really into Dudes</td><td style="text-align:center">2</td><td style="text-align:center">100</td><td style="text-align:center">爱情片</td></tr><tr><td>Beautiful Woman</td><td style="text-align:center">1</td><td style="text-align:center">81</td><td style="text-align:center">爱情片</td></tr><tr><td>Kevin Longblade</td><td style="text-align:center">101</td><td style="text-align:center">10</td><td style="text-align:center">动作片</td></tr><tr><td>Robo Slayer</td><td style="text-align:center">99</td><td style="text-align:center">5</td><td style="text-align:center">动作片</td></tr><tr><td>Amped II</td><td style="text-align:center">98</td><td style="text-align:center">2</td><td style="text-align:center">动作片</td></tr><tr><td>?</td><td style="text-align:center">18</td><td style="text-align:center">90</td><td style="text-align:center">未知</td></tr></tbody></table><p>我们可以把数据抽象为一个向量（或者看成坐标点），比如California Man的数据就可以抽象成(3,104)；那如何计算两部电影之间的相似性呢？在这里我们可以使用欧式距离公式来计算两个向量点之间的距离：<br>$$<br>d=\sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2}<br>$$<br>那未知电影与California Man之间的距离计算为：<br>$$<br>d=\sqrt{(18-3)^2+(90-104)^2}=20.5<br>$$<br>同理，其他电影与未知电影之间的距离也可以计算，最后按距离递增排序：</p><table><thead><tr><th>电影名称</th><th style="text-align:center">与未知电影的距离</th></tr></thead><tbody><tr><td>California Man</td><td style="text-align:center">20.5</td></tr><tr><td>He ‘s Not Really into Dudes</td><td style="text-align:center">18.7</td></tr><tr><td>Beautiful Woman</td><td style="text-align:center">19.2</td></tr><tr><td>Kevin Longblade</td><td style="text-align:center">115.3</td></tr><tr><td>Robo Slayer</td><td style="text-align:center">117.4</td></tr><tr><td>Amped II</td><td style="text-align:center">118.9</td></tr></tbody></table><p>如果我们假定k=3，则最靠近的电影依次是California Man、He ‘s Not Really into Dudes和Beautiful Woman。k-近邻算法按照距离最接近的三部电影来决定未知电影的类型，而这三部全部都是爱情片，因此我们判断未知电影也是爱情片。</p><p>接下来上knn算法的代码代码是python，需要导入numpy第三方包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX,dataSet,labels,k)</span>:</span></div><div class="line">dataSetSize = dataSet.shape[<span class="number">0</span>]//取矩阵的列数</div><div class="line">diffMat = tile(inX,(dataSetSize,<span class="number">1</span>))-dataSet//建立未知电影的矩阵，并减去样本矩阵</div><div class="line">sqDiffMat = diffMat**<span class="number">2</span></div><div class="line">sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</div><div class="line">disatances = sqDistances**<span class="number">0.5</span>//计算欧式距离</div><div class="line">sortedDistIndicies = disatances.argsort()//递增排序</div><div class="line">classCount=&#123;&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k)://对前k个数据的类别计数，返回出现次数最多的类别</div><div class="line">voteIlabel = labels[sortedDistIndicies[i]]</div><div class="line">classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>)+<span class="number">1</span></div><div class="line">sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">print</span> classCount,sortedClassCount</div><div class="line"><span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</div></pre></td></tr></table></figure><p>classify0() 函数有4个输入参数：用于分类的输入向量是inX，输入的训练样本集为dataSet，标签向量为labels（爱情片抽象为1，动作片抽象为0），最后的参数k表示用于选择最近邻居的数目，其中标签向量的元素数目和矩阵dataSet的行数相同。</p><p>为了更好理解，我把例子中的输入的参数也贴出来：<br>$$<br>inX=\left[\begin{matrix}<br>        18 &amp; 90 \<br>        \end{matrix}\right]<br>$$</p><p>$$<br>dataSet=\left[\begin{matrix}<br>        3 &amp; 104 \\<br>        2 &amp; 100 \\<br>        1 &amp; 81 \\<br>        101 &amp; 10 \\<br>        99 &amp; 5 \\<br>        98 &amp; 2 \\<br>        \end{matrix}\right]<br>$$</p><p>$$<br>labels=\left[\begin{matrix}<br>        1 \\<br>        1 \\<br>        1 \\<br>        0 \\<br>        0 \\<br>        0 \\<br>        \end{matrix}\right]<br>$$</p><p>我们已经成功使用k-近邻算法构造了一个分类器，想想看分类器一定是正确的吗？答案是否定的，分类器并不会得到百分百正确的结果，因为分类器还会受到多种因素的影响，比如数据集和k值的变化就可能产生不同的结果；我们可以多种方法来检测分类器的准确率。</p><p>接下来我们用一个实际的案例来演示完整的分类器，图像识别是机器学习领域的一个典型应用，其本质原理是把图像转化为电脑能够识别的二进制文件，再通过复杂的分类算法来识别图像，在这里我们先尝试用一个简化版数据集来实践，假设我们有一批处理后的样本集，其中一个文件如下，它的分类是数字3：</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170328/222305843.png" alt="mark"></p><p>那么如何去识别一个新的数字呢？接下来上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span>//根据样本创建一个<span class="number">1</span>行<span class="number">1024</span>列的训练矩阵</div><div class="line">returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</div><div class="line">fr = open(filename)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">lineStr = fr.readline()</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</div><div class="line"><span class="keyword">return</span> returnVect</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></div><div class="line">hwLabels = []</div><div class="line">traningFileList = listdir(<span class="string">'trainingDigits'</span>)//根据样本创建一个m行<span class="number">1024</span>列的训练矩阵</div><div class="line">m = len(traningFileList)</div><div class="line">traningMat = zeros((m,<span class="number">1024</span>))</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m)://根据文件名解析出分类数字</div><div class="line">fileNameStr = traningFileList[i]</div><div class="line">fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line">classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</div><div class="line">hwLabels.append(classNumStr)</div><div class="line">traningMat[i,:] = img2vector(<span class="string">'trainingDigits/%s'</span>%fileNameStr)</div><div class="line">testFileList = listdir(<span class="string">'testDigits'</span>)</div><div class="line">errorCount = <span class="number">0.0</span></div><div class="line">mTest = len(testFileList)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(mTest)://用测试集来计算分类器的准确率</div><div class="line">fileNameStr = testFileList[i]</div><div class="line">fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line">classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</div><div class="line">vectorUnderTest = img2vector(<span class="string">'testDigits/%s'</span>%fileNameStr)</div><div class="line">classifierResult = classify0(vectorUnderTest,traningMat,hwLabels,<span class="number">3</span>)</div><div class="line"><span class="keyword">print</span><span class="string">"the classfifier came back with: %d,the real answer is :%d"</span>%(classifierResult,classNumStr)</div><div class="line"><span class="keyword">if</span>(classifierResult != classNumStr):errorCount += <span class="number">1.0</span></div><div class="line"><span class="keyword">print</span> <span class="string">"\nthe total number of errors is: %d"</span>%errorCount</div><div class="line"><span class="keyword">print</span> <span class="string">"\nthe total error rate is %f"</span>%(errorCount/float(mTest))</div></pre></td></tr></table></figure><p>因为数据集是txt文件，每一个文件名格式都是 3_7.txt，其中3是该样本的实际分类，7是该样本在3分类下的id，分类器先把trainingDigits目录下的所有样本集转成1024维的训练矩阵，再把testDigits目录下的所有测试集也转成1024维的矩阵，再用之前的classify0() 函数来分类，最后再对比分类器分类结果和实际分类，以此来计算分类器的准确率。</p><p>最后总结一下，knn近邻算法就像是“近朱者赤，近墨者黑”，如果一部电影的打斗镜头和接吻镜头与另外k部接近，knn近邻算法就会判断这部电影属于另外k部电影中占多数的类型。</p><p><a href="http://download.csdn.net/detail/u012491566/6474803" target="_blank" rel="external">本文的数据集和代码下载&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习实战-k近邻算法（knn）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>游戏背后的数据分析</title>
    <link href="http://zikang.me/2017/01/05/20170105-%E6%B8%B8%E6%88%8F%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://zikang.me/2017/01/05/20170105-游戏背后的数据分析/</id>
    <published>2017-01-05T12:09:49.000Z</published>
    <updated>2017-04-04T10:11:05.265Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>“数据分析注重的是结果转化，理论和知识最终服务于方案和效果。游戏可以看作是一件艺术品，然而这样一件艺术品是需要受众的，要经营受众，我们就需要去衡量，去改进。在这个过程中，所使用的工具不是最关键的，使用的算法也不是最关键的，解决问题的方法才是最关键的，并有切实落地的方案以及对于最终效果的反馈和改进措施。不只是游戏数据分析是这样的，对于其他领域的数据分析也是如此。”——《游戏数据分析的艺术》</p><p>我们越来越专注和追求产品设计、体验、运营和用户的获取，正是在这样的大背景下，数据分析也变得越来越来重要，我们需要了解如何获取新用户，评估效果；我们需要了解如何激活用户、评估产品质量；我们也需要知道如何提升收益，并挖掘潜用户的价值。</p><p>游戏数据的分析是一个完整的流程，分析从业务需求出发，构建相应的数据指标体系，在游戏的关键步骤上埋点比如注册、创建角色、完成第一个任务，当用户触发事件时客户端会生成相应的日志发送给服务端并保存，数据分析师再从服务端的数据库里取出相应的日志，再把日志进行筛选取出想要的那部分进行统计计算，最后根据计算结果找到可以优化的细节再反馈给游戏运营和游戏研发，这样一个数据分析的流程才算完成。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/171053743.jpg" alt="mark"></p><p>在任何一款产品的生命周期中，都需要不断思考三个问题。</p><ul><li>如何有效获取用户</li><li>如何有效经营用户</li><li>如何提升用户付费</li></ul><h2 id="如何有效获取用户"><a href="#如何有效获取用户" class="headerlink" title="如何有效获取用户"></a>如何有效获取用户</h2><p>移动设备就是一个社交环境，游戏是一种沟通方式，最好的游戏体验是寻求能力与挑战之间的最佳平衡。而挑战一部分源于游戏本身，另一部分则是来自于社交属性，这种社交一方面是竞争，例如游戏中的排行榜，微信的熟人社交关系而呈现的排行榜等。另一方面则是对于自身超预期的能力认识所造成的。例如在地铁上，你看见一个人在玩跑酷游戏，而此时的你已经被感染，甚至觉得如果此时你正在玩这款游戏，你一定比那个人强很多倍。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/171044205.jpg" alt="mark"></p><p>在过去很多的用户获取方式，有网吧地面推广、网站展示广告以及电视媒体广告等，之所以如此，是因为在过去基于cookie技术和受众分析，但没办法预先非常精准了解哪些要被营销用户的兴趣、属性以及认知。因为在过去无法做对一个用户的精准分析和行为刻画。但是在今天智能设备不只是一个娱乐工具，实际是一个数据收集器，在不违背用户隐私的原则下，比以往任何时候都更加清楚用户的情况。这其实带来更多的思考，尤其是在数据分析以及价值转化方面。</p><p>对于产品的推广，往往需要在用户量和质量上有所考虑，很多时候较高的广告预算，会选择激进的大面积的广告购买和投放，以期望在初期获得更多的用户资源和流量，实际上，激进投放反倒损失更多的资金和用户。虽然精准投放和自然用户规模很小，但质量最佳，经历了长期的用户沉淀，稳定的留存，即使每天只有10000新增用户，一周后至少理论应该有70000的日活跃用户，当然这是在新用户一个不流失的前提下得出的数字，这一点能说明一个问题，不积跬步，无以至千里。移动游戏比较常见的推广的方式有：应用市场、预装、刷机、应用广告、积分墙、各种社区推广。</p><p>核心指标：注册数、创建数、创建率、付费率、次日留存</p><h2 id="如何有效的经营用户"><a href="#如何有效的经营用户" class="headerlink" title="如何有效的经营用户"></a>如何有效的经营用户</h2><p>关键还是优化产品，比如等级设计、关卡设计，界面设计等等，用户要离开有太多的理由，我们能做就是优化设计和活动运营，把用户挽留住。</p><p>广告的最终目的是寻找到最佳匹配，进而提升效率，而对于这个效果的衡量，留存率是非常重要的一方面，当然订单转化数，付费情况也是效果衡量的标准。如果分析留存率，哪些要素是必须要关注的，我认为有三点：</p><ul><li>环境：获取用户的方式、渠道、方法</li><li>用户：获取用户的质量、效果、兴趣</li><li>产品：本身产品的质量和人群受众定位</li></ul><p>留存率达标了，才可以进行推广，由封测期间的自然用户的留存率表现来确定是否可以进行推广，尽管在推广期的留存率一定是偏低的。三个要素其实就是影响留存率的关键要素。如果用一个词来形容，就是体验。实际上，在线广告传播漏斗及设计整体的转化路径就是一个体验过程，虽然背后支撑的是数据、技术，如果忽略了用户、环境和产品本身的因素，就很难单纯从数据分析和技术角度完成效果的优化和提高。因为用户永远只会去感受，即听到的，看到的，触摸的，这就是体验。</p><p>当用户进入APP Store时，用户是有主动的内在发现游戏、下载游戏的需求，这是关键的驱动力，其中的环境因素（在APP Store商店中找游戏时，大多数是在WIFI网络条件下）、用户兴趣（有发现寻找某些类型游戏的需求）和产品宣传（产品的核心特点和包装也是用户选择的驱动力）都会有非常重要的作用，然而当我们在电台或小说应用中开始展示广告时，用户实际上并没有这方面的需求和获取游戏的动力，也许此时用户手机中已经安装了一款同一题材、同一玩法的游戏。最终来看，留存率可能并不是很理想，尤其是在近期不断流行的积分墙方式，尽管有效果要求，但是却很少能保证留存或者是付费效果，就是因为上述因素的制约。如同早期的游戏刷榜一样，积分墙也是在改变榜单权重，进而获得更多的曝光机会，从而更大概率地获得正真属于游戏的用户。只是在这种模式下，只考虑了产品宣传，用户的环境和目标受众是否需要这样的内容，是否会恰当的在用户面前曝光，则是一个现实的难题。</p><p>所谓用户体验，或者深入一点就是用户的行为和心理需求，就是要把握住用户的情感，设计内容的耐玩性和趣味性，抓住用户的核心诉求，了解用户放弃的原因（比如痛苦、失败、麻烦、不一致）。从获取用户角度，就是提到的留存率三要素。</p><p>这种体验是在用户接触到游戏的时候就已经产生了。一个用户选择了什么渠道，看到了什么描述、什么关键字、什么截图、什么下载、什么安装进度、什么首次加载、什么二次加载……就已经诞生了体验，用户流失不是一触而就的，而是不断积累的，等达到体验上的“耐受点”时，用户就会突然离开，而且是毫无征兆的。在上述的描述中，就涉及到环境、用户和产品。</p><p>回到留存本身，即使那些在7日还返回的游戏玩家，并不是在新增后的每一天都会一直登录游戏，这点是有数据参考的，可以计算一下新增用户在新增日后到第7日之间的登录分布。体验成为游戏想要去获得更高7日留存的关键因素，因为你会发现其实现在游戏呈现的玩法本质上没有什么差异，而且太多的用户还没有接触到这个玩法就已经开始流失了；另一种情况，在最初的几天用户就充分掌握了游戏的玩法，那么接下来的留存率该如何优化，将决定游戏的用户规模。因为手游相比页游和端游有更加低廉的放弃成本，投入成本也很少。那么，体验则成为最关键的影响因素。而体验也不止是一套UI，实际上跟用户有关的视觉、触觉和听觉都属于体验的范畴。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/171034229.jpg" alt="mark"></p><p>当用户对自己所付出的成本和时间都可见的时候，用户是很难放弃游戏的。例如，在策略游戏《部落冲突》中，不断升级的建筑，越来越复杂的操作和布局，都让用户得到了一种内心的愉悦。当用户收到一条消息，了解到自己的家园被别人毁掉的时候，用户会毫不犹豫的进入游戏查看，选择是否复仇或者修补。换句话说，此时是通过游戏机制来提升产品粘性，不断地刺激用户，进而长久的留存下来。移动设备最大的变化是用户很难在同一屏幕做两件事，这也注定了用户设备使用是碎片化的，作为游戏很难长时间霸占用户的屏幕，至少持续的时间不会很久。</p><p>所以，有什么能够刺激用户在一天中再次主动打开和关注游戏，这是最重要的，因为一旦解决了这点，等同于游戏的留存率会有很好的表现。移动设备的粘性源于用户对未知内容的追求，无论是我们看到手机屏幕显示的一条未读信息，还是看到我们游戏中的家园被人摧毁，都会存在一种本源动力去挖掘和了解真相，甚至会在最初的一段时间内在期盼下一秒、下一分钟或者下一小时可能发生的事情。例如我们每天都不断刷新自己的朋友圈，这都是对于位置内容和信息的挖掘，这就是粘性。</p><p>核心指标：留存率、活跃用户、付费率</p><h2 id="如何提升用户付费"><a href="#如何提升用户付费" class="headerlink" title="如何提升用户付费"></a>如何提升用户付费</h2><p>每一笔收入都源于每一个用户经历发现游戏（广告曝光展示）、单击、下载、安装、激活、活跃和留存的过程，最终完成付费转化，带来的游戏收入。在这个过程中，每一步都将面临用户的不断流失，以及衡量效果的转化率。习惯于站在运营角度来进行收入分析，却忘记了收入是源于潜在用户转化而形成的。</p><p>所以，收入的分析从来都不是只针对付费用户的分析。站在用户角度，实际上要更加关心这批用户是如何转化成付费用户的。因此收入分析将从两个角度入手，一个是市场推广，这属于外部流量因素；另一个是产品运营，这属于内部的内容因素。</p><p>从用户获取和市场推广角度，关心话题如下。</p><ol><li>每一个激活用户花4元钱，那么这个用户多久才能赚回4元？</li><li>一次推广活动两天总计花费10万元，带来4万用户，那么随后第几天这次推广活动赚回10万元？</li></ol><p>以上两个问题，实际上就是一个简单的ROI（投资回报率）问题，即投入与产出之间的一个衡量，当让ROI必须考虑收益、时间和质量3个要素。第一个问题是从单个用户角度来考虑的，而第二个是对整体的一次效果分析，其实就是CAC（推广激活单价，即每个新用户的成本）和LTV（生命周期总价值）之间的对比。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/171025093.png" alt="mark"></p><p>表是两种不同的推广方案，A方案是按照普通投放的形式，B方案是按照用户兴趣的精准投放形式。</p><p>下面，以统计两种推广方案所获取用户的7日收益为标准来分析。</p><p>对A方案的ROI计算如下：</p><p>ROI=（50000-0）/30000=1.67</p><p>对B方案的ROI计算如下：</p><p>ROI=（80000-0）/32000=2.5</p><p>此处的成本为0主要原因是游戏销售的是成本趋近为0的虚拟商品，因此整个利润就是游戏实际所赚到的收入。粗略计算后，发现了B方案的ROI已经远远好于A方案。下面将通过衡量CAC与LTV进行对比。</p><p>对于A方案，推广后的第5天收回30000元成本，且截至7日，收益为50000</p><p>LTV=（50000-30000）/10000=2</p><p>CAC=30000/10000=3</p><p>即LTV:CAC=2：3</p><p>对于B方案，推广后第3天收回32000元成本，且截至7日，收益为80000</p><p>LTV=（80000-32000）/8000=6</p><p>CAC=32000/8000=4</p><p>即LTV:CAC=6：4</p><p>在A方案中，收回成本后的两天时间，每个用户的LTV是2元，而得到这样一个用户需要3元，而此时的2元是纯粹的利润，因为获取用户的成本已经在前5天时间被均摊，但LTV还是低于CAC，随着对14日收益或者30日收益的计算，LTV则逐渐增长，但取决于用户的留存率。</p><p>在B方案中，收回成本需要三天时间，意味着剩下4天时间都是纯粹的利润，经过计算，此时LTV为6元，而此时的CAC为4元，在B方案用3天时间均摊了获取用户成本的情况下，其随后的纯利润是A方案的3倍，且LTV已经大于CAC，并且留存率也是由于A方案的用户投放效果。</p><p>对于收入分析，其实缺失最多的就是从ROI的角度来分析，一方面是受限于早期游戏的用户获取和推广方式依赖于一些线下渠道，从用户衡量角度来说很难反映出来；另一方面，游戏是一个注重用户运营和产品内容的行业，因此相对来说收入分析更多反映的是运营和内容相关的，而如何去挖掘潜在目标用户是历来都是思考的问题。对于收入相关分析其实也是一样的，因此理解用户获取相关数据和针对收入分析的辅助是必要的。</p><p>而如何提升付费就要考虑用户是如何转化成付费用户的，这实际上存在一个转化过程：</p><p>1、发现合适的商品</p><p>这一点无论是对于移动游戏还是pc游戏，都是非常关键的。如同受到微信朋友发来的消息一样，只有当玩家最需要的时候，提醒其存在，其转化则是最有效的。相比于pc游戏，移动端的推送可以直接触达用户的手机屏幕，要确保传达的付费点在用户心目中确实是属于应该付费的道具或者商品。在此环节中，利用产品的积累和有效的信息推送，会促进用户发现内容。</p><p>2、找哪儿有卖的</p><p>当用户有需要的时候，直接告诉用户能够购买的位置，这一点是非常重要的。除了提醒存在之外，还需要让付费点变得容易发现，提高曝光度，聚集用户的注意力。所以，在移动游戏中，适当的公告栏、关键信息的标注展示，都在帮助用户和驱动用户转化，在这个环节，要不断提升易用性，包括内容的衔接和转化上，都需要体现对用户的关怀。</p><p>3、期待价值评估</p><p>当用户接触产品时，会建立对产品的初步印象，进而形成期待，即转化的概率，而用户一旦完成转化或者受到其他因素干扰时，会形成一个价值反馈或者决定，当价值反馈大于期待时，用户很有可能选择购买。而在评估过程中，有一些因素对于促进付费转化具有关键作用，例如以下几点：</p><ul><li>个性化：付费内容是否可以体现玩家的个性，展现玩家的能力（部落冲突的围墙）</li><li>可替代性：付费点是否存在多项类似的选择（穿越火线中的武器）</li><li>信息真实性：付费点是否如描述所说的真实可靠</li><li>性价比：用户是否觉得付费值得</li><li>时机：什么时候购买或者付费最重要（活动期间、开服期间）</li><li>流行度：随着时间、节日等节点存在的付费内容别人都有，自己也需要有</li><li>象征性：在游戏中的一些头衔、数值或道具（魔兽世界成就）</li></ul><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/171013733.jpg" alt="mark"></p><p>4、做出的购买决策</p><p>如果上述步骤进展顺利，那么这一步也会很快转化，但是如果用户在购买过程中，遇到更多的可变因素，就会导致用户放弃购买，比如支付失败、购买流程太多等等都会影响用户的购买决策。</p><p>5、购后行为</p><p>在付费前存在期待反馈，在付费后也有期待反馈，用户的实际付费效果完全好于预期，则会驱动产生新的付费需求，包括一些内容刺激。例如在卡牌游戏中，目前普遍采用付费用户阶梯概率，当用户付费达到一定规模后，用户通过抽奖得到的极品卡牌的概率就会提升，进而产生二次付费。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/170939570.png" alt="mark"></p><p>核心指标：LTV、ARPU、付费率</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;“数据分析注重的是结果转化，理论和知识最终服务于方案和效果。游戏可以看作是一件艺术品，然而这样一件艺术品是需要受众的，要经营受众，我们就需要去衡量，去改进。在这个过程中，所使用的工具不是最关键的，使用的算法也不是最关键的，解决问题的方法才
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python爬虫实践</title>
    <link href="http://zikang.me/2016/12/24/20161224-python%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zikang.me/2016/12/24/20161224-python爬虫实践/</id>
    <published>2016-12-24T14:25:46.000Z</published>
    <updated>2017-04-04T10:10:42.727Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>之前有看到很多数据分析报告都是利用爬虫来获得原始数据，自己也想实践一下，理清楚爬虫的工作原理，本实例来源于慕课网<a href="http://www.imooc.com/learn/563" target="_blank" rel="external"> http://www.imooc.com/learn/563</a>，实例实现的目标是抓取百度百科1000个页面的数据。</p><p>一个基本的爬虫程序包括调度器、URL管理器、下载器和解析器，下图是爬虫的运行流程，从调度器开始调用URL管理器来获取待爬取的URL，再通过下载器把URL的内容下载到本地，最后通过解析器把内容解析成需要的数据并且再返回新的需要爬取的URL；其中调度器相当于是一个命令发布枢纽和中转站，由它来指挥三大模块（URL管理器、下载器、解析器）工作，并最终将价值数据输送给应用端。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/175904616.png" alt="mark"></p><p>URL管理器的核心就是管理待抓取和已抓取的URL集合</p><ol><li>管理待抓取URL集合：先判断该URL是否已在容器内，是，不添加；不是，添加。</li><li>管理已抓取URL集合：分三部分：判断是否还有待爬取的URL—获取待爬取URL—爬取后，将URL从待爬取移动到已爬取</li></ol><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/175919265.png" alt="mark"></p><p>网页解析器，解析出目标网页中的内容，若有新url再回传给url管理器，BeatifulSoup就是使用DOM树解析网页</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/175928841.png" alt="mark"></p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/175939224.png" alt="mark"></p><p>网页下载器：将URL指定的网页下载下来存储成一个字符串，传送给网页解析器；python里网页下载器有 urllib2 和 第三方包requests</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/175946688.png" alt="mark"></p><p>接下来贴代码</p><p> 调度器 spider_main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> url_manager,html_downloader,html_parser,html_outputer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMain</span><span class="params">(object)</span>:</span></div><div class="line"><span class="string">"""docstring for ClassName"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">self.urls = url_manager.UrlManager()</div><div class="line">self.downloader = html_downloader.HtmlDownloader()</div><div class="line">self.parser = html_parser.HtmlParser()</div><div class="line">self.outputer = html_outputer.HtmlOutputer()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self, root_url)</span>:</span></div><div class="line">count = <span class="number">1</span></div><div class="line">self.urls.add_new_url(root_url)</div><div class="line"><span class="keyword">while</span> self.urls.has_new_url():</div><div class="line"><span class="keyword">try</span>:</div><div class="line">new_url = self.urls.get_new_url()</div><div class="line"><span class="keyword">print</span> (<span class="string">'craw %d : %s '</span> % (count, new_url))</div><div class="line">html_cont = self.downloader.download(new_url)</div><div class="line">new_urls,new_data = self.parser.parser(new_url,html_cont)</div><div class="line">self.urls.add_new_urls(new_urls)</div><div class="line">self.outputer.collect_data(new_data)</div><div class="line"></div><div class="line"><span class="keyword">if</span> count == <span class="number">10</span>:</div><div class="line">print(<span class="string">'10'</span>)</div><div class="line"><span class="keyword">break</span></div><div class="line"></div><div class="line">count = count + <span class="number">1</span></div><div class="line"><span class="keyword">except</span> :</div><div class="line"><span class="keyword">print</span> (<span class="string">'craw failed'</span>)</div><div class="line"></div><div class="line"></div><div class="line">self.outputer.output_html()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">root_url = <span class="string">"http://baike.baidu.com/view/21087.htm"</span></div><div class="line">obj_spider = SpiderMain()</div><div class="line">obj_spider.craw(root_url)</div></pre></td></tr></table></figure><p> url管理器 url_manager.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlManager</span><span class="params">(object)</span>:</span></div><div class="line"><span class="string">"""docstring for UrlManager"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">self.new_urls = set()</div><div class="line">self.old_urls = set()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_new_url</span><span class="params">(self, url)</span>:</span></div><div class="line"><span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line"><span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.new_urls <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.old_urls:</div><div class="line">self.new_urls.add(url)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_new_urls</span><span class="params">(self, urls)</span>:</span></div><div class="line"><span class="keyword">if</span> urls <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(urls) == <span class="number">0</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">self.add_new_url(url)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_new_url</span><span class="params">(self)</span>:</span></div><div class="line"><span class="keyword">return</span> len(self.new_urls) != <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_new_url</span><span class="params">(self)</span>:</span></div><div class="line">new_url = self.new_urls.pop()</div><div class="line">self.old_urls.add(new_url)</div><div class="line"><span class="keyword">return</span> new_url</div></pre></td></tr></table></figure><p> 网页下载器 html_downloader.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span><span class="params">(object)</span>:</span></div><div class="line"><span class="string">"""docstring for HtmlDownloader"""</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self,url)</span>:</span></div><div class="line"><span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line"><span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">response = urllib.request.urlopen(url)</div><div class="line"><span class="keyword">if</span> response.getcode() != <span class="number">200</span>:</div><div class="line"><span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> response.read()</div></pre></td></tr></table></figure><p> 网页解析器 html_parser.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> urllib.parse</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></div><div class="line"><span class="string">"""docstring for HtmlParser"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser</span><span class="params">(self, page_url, html_cont)</span>:</span></div><div class="line"><span class="keyword">if</span> page_url <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> html_cont <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line"></div><div class="line">soup = BeautifulSoup(html_cont,<span class="string">'html.parser'</span>,from_encoding=<span class="string">'utf-8'</span>)</div><div class="line">new_urls = self._get_new_urls(page_url, soup)</div><div class="line">new_data = self._get_new_data(page_url, soup)</div><div class="line"><span class="keyword">return</span> new_urls,new_data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_new_urls</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">new_urls = set()</div><div class="line">links = soup.find_all(<span class="string">'a'</span>, href=re.compile(<span class="string">r"/view/\d+\.htm"</span>))</div><div class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</div><div class="line">new_url = link[<span class="string">'href'</span>]</div><div class="line">new_full_url = urllib.parse.urljoin(page_url, new_url)</div><div class="line">new_urls.add(new_full_url)</div><div class="line"><span class="keyword">return</span> new_urls</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_new_data</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">res_data = &#123;&#125;</div><div class="line"></div><div class="line">res_data[<span class="string">'url'</span>] = page_url</div><div class="line"></div><div class="line">title_node = soup.find(<span class="string">'dd'</span>, class_=<span class="string">"lemmaWgt-lemmaTitle-title"</span>).find(<span class="string">"h1"</span>)</div><div class="line">res_data[<span class="string">'title'</span>] = title_node.get_text()</div><div class="line"></div><div class="line">summary_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"lemma-summary"</span>)</div><div class="line">res_data[<span class="string">'summary'</span>] = summary_node.get_text()</div><div class="line"></div><div class="line"><span class="keyword">return</span> res_data</div></pre></td></tr></table></figure><p> 数据输出 html_outputer.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlOutputer</span><span class="params">(object)</span>:</span></div><div class="line"><span class="string">"""docstring for HtmlOutputer"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">self.datas = []</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect_data</span><span class="params">(self,data)</span>:</span></div><div class="line"><span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line"><span class="keyword">return</span></div><div class="line">self.datas.append(data)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">output_html</span><span class="params">(self)</span>:</span></div><div class="line">fout = open(<span class="string">'output.html'</span>, <span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"></div><div class="line">fout.write(<span class="string">"&lt;html&gt;"</span>)</div><div class="line"></div><div class="line">fout.write(<span class="string">"&lt;meta charset=\'utf-8\'&gt;"</span>)</div><div class="line">fout.write(<span class="string">"&lt;body&gt;"</span>)</div><div class="line">fout.write(<span class="string">"&lt;table&gt;"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</div><div class="line">fout.write(<span class="string">"&lt;tr&gt;"</span>)</div><div class="line">fout.write(<span class="string">"&lt;td&gt;%s&lt;/td&gt;"</span> % data[<span class="string">'url'</span>])</div><div class="line">fout.write(<span class="string">"&lt;td&gt;%s&lt;/td&gt;"</span> % data[<span class="string">'title'</span>])</div><div class="line">fout.write(<span class="string">"&lt;td&gt;%s&lt;/td&gt;"</span> % data[<span class="string">'summary'</span>])</div><div class="line">fout.write(<span class="string">"&lt;/tr&gt;"</span>)</div><div class="line"></div><div class="line">fout.write(<span class="string">"&lt;/table&gt;"</span>)</div><div class="line">fout.write(<span class="string">"&lt;/body&gt;"</span>)</div><div class="line">fout.write(<span class="string">"&lt;/html&gt;"</span>)</div><div class="line"></div><div class="line">fout.close()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;之前有看到很多数据分析报告都是利用爬虫来获得原始数据，自己也想实践一下，理清楚爬虫的工作原理，本实例来源于慕课网&lt;a href=&quot;http://www.imooc.com/learn/563&quot; target=&quot;_blank&quot; rel=&quot;e
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何建立用户画像</title>
    <link href="http://zikang.me/2016/11/26/20161126-%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    <id>http://zikang.me/2016/11/26/20161126-如何建立用户画像/</id>
    <published>2016-11-26T15:18:15.000Z</published>
    <updated>2017-04-04T10:10:22.230Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="什么是用户画像"><a href="#什么是用户画像" class="headerlink" title="什么是用户画像"></a>什么是用户画像</h2><p>用户画像是描述产品典型使用者的标签聚合，比如A用户：男，35岁，工作和家都在北京，大数据公司高层，月收入3万以上，博士生导师，喜欢网购和传奇类游戏，那么可以用下面的图来表示：</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/174720615.jpg" alt="mark"><br>用户画像一般包括两个纬度，一个是用户基本属性，另一个是用户行为。</p><p>用户基本属性是静态的，比如性别、年龄、地区、学历、职业、收入、浏览器、IE版本、系统版本等等，这一类的属性越多越用户形象就越清楚。</p><p>用户行为一定程度上取决于用户的基本属性，但这个数据指标是动态的，比如使用时常、使用频率、充值金额、充值频率等，这一数据对核心指标产生直接影响。</p><h2 id="用户画像的作用"><a href="#用户画像的作用" class="headerlink" title="用户画像的作用"></a>用户画像的作用</h2><p>用户画像的核心工作是为用户打标签，打标签的重要目的之一是为了让人能够理解并且方便计算机处理，如，可以做分类统计：喜欢传奇类的用户有多少？喜欢传奇类的人群中，各年龄层分布是怎样一种情况？也可以做数据挖掘工作：利用关联规则计算，喜欢网购的用户有多少喜欢传奇类游戏？利用聚类算法分析，喜欢传奇类的地区分布是怎样？</p><p>大数据处理，离不开计算机的运算，标签提供了一种便捷的方式，使得计算机能够程序化处理与人相关的信息，甚至通过算法、模型能够“理解” 人。当计算机具备这样的能力后，无论是搜索引擎、推荐引擎、广告投放等各种应用领域，都将能进一步提升精准度，提高信息获取的效率。</p><h2 id="如何建立用户画像"><a href="#如何建立用户画像" class="headerlink" title="如何建立用户画像"></a>如何建立用户画像</h2><p>1、获取数据</p><p>获取基本属性，可以通过注册时填写的基本信息、用户访问时获取的设备信息、微博/QQ/微信这样用户授权的第三方登录信息等方式来获取，因为基本属性的值是固定的，比如性别只有男和女，所以更多的是数据清洗工作。但在某些情况下用户的基本属性很难获得时，就可以采用A/B测试的方法来判断属性值，比如现在只知道用户是男性但不知道用户的年龄，那我们可以利用抽奖活动，在奖品页面进行SDK埋点，并设置适合20~30岁和30~40岁两种不同年龄段使用的礼品，根据用户的选择来判断用户的年龄段。除此之外也可以通过问卷调查的方式来直接获取用户数据。</p><p>获取用户行为，先要在所有用户执行闭环操作流程上的关键位置埋点，用户在点击时直接产生网络行为数据（登陆次数、访问时长、激活率、外部触点、社交数据）以及服务内行为数据（浏览路径、页面停留时间、访问深度、唯一页面浏览次数等等），数据再反馈到服务器，被存放于后台或者客户端，这样我们就能通过访问数据库来使用这些数据。用户行为的跟踪主要包括三个维度：场景+媒体+路径，应用到互联网中，场景主要包括访问设备、访问时段，媒体指某一时段下用户具体访问的媒体，如资讯类、视频类、游戏类、社交类等，路径指用户进入和离开某媒体的路径，可以简单理解为用户的站内与站外行为，如是通过搜索导航进入还是直接打开该APP，离开时是站内跳转到其他网页还是直接关闭。</p><p>上述定量化的调研可以快速对用户建立一个精准的认识，对不同数量、不同特征的用户进行比较统计分析，在后期产品迭代改进的过程中可以将用户进行优先级排序，着重关注核心的、规模大的用户。但是，依靠数据这种偏定量的方式建立的用户画像依然是粗线条的，难以描述典型用户的生活情景、使用场景，难以挖掘用户情感倾向和行为操作背后的原因和深层次动机。因此，如果有足够精力和时间，后续可以对每类用户进行深入的访谈，将定量和定性的方法结合起来，建立的用户画像会更为精准和生动。</p><p>2、数据建模</p><p>给用户的行为标签赋予权重就是数据建模的一个典型方式（更深入的用户聚类算法我将在以后的文章中介绍）<br>用户的行为，我们可以用4w表示： WHO（谁）；WHEN（什么时候）；WHERE（在哪里）；WHAT（做了什么），具体分析如下：</p><p><strong>WHO</strong>：定义用户，明确我们的研究对象。主要是用于做用户分类，划分用户群体。网络上的用户识别，包括但不仅限于用户注册的ID、昵称、手机号、邮箱、身份证、微信微博号等等。</p><p><strong>WHEN</strong>：这里的时间包含了时间跨度和时间长度两个方面。“时间跨度”是以天为单位计算的时长，指某行为发生到现在间隔了多长时间；“时间长度”则为了标识用户在某一页面的停留时间长短。越早发生的行为标签权重越小，越近期权重越大，这就是所谓的“时间衰减因子”。</p><p><strong>WHERE</strong>：就是指用户发生行为的接触点，里面包含有内容+网址。内容是指用户作用于的对象标签，比如小米手机；网址则指用户行为发生的具体地点，比如小米官方网站。权重是加在网址标签上的，比如买小米手机，在小米官网买权重计为1,，在京东买计为0.8，在淘宝买计为0.7。</p><p><strong>WHAT</strong>：就是指的用户发生了怎样的行为，根据行为的深入程度添加权重。比如，用户购买了权重计为1，用户收藏了计为0.85，用户仅仅是浏览了计为0.7。<br>当上面的单个标签权重确定下来后，就可以利用标签权重公式计算总的用户标签权重：</p><p>标签权重=时间衰减因子×网址权重×行为权重</p><p>举个栗子：A用户今天在小米官网购买了小米手机；B用户七天前在京东浏览了小米手机。由此得出单个用户的标签权重，打上“是否忠诚”的标签。</p><table><thead><tr><th>用户</th><th>时间衰减因子</th><th>网址权重</th><th>行为权重</th><th>用户标签权重</th><th>结论</th></tr></thead><tbody><tr><td>A</td><td>今天（1）</td><td>在官网（1）</td><td>购买（1）</td><td>1 <em> 1 </em> 1 = 1</td><td>忠实米粉</td></tr><tr><td>B</td><td>七天前（0.7）</td><td>在京东（0.8）</td><td>浏览（0.7）</td><td>0.7 <em> 0.8 </em> 0.7 = 0.39</td><td>一般用户</td></tr></tbody></table><p>通过这种方式对多个用户进行数据建模，就能够更广的覆盖目标用户群，为他们都打上标签，然后按照标签分类：总权重达到0.9以上的被归为忠实用户，他们都购买了该产品。这样的一来，企业和商家就能够根据相关信息进行更加精准的营销推广、个性化推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;什么是用户画像&quot;&gt;&lt;a href=&quot;#什么是用户画像&quot; class=&quot;headerlink&quot; title=&quot;什么是用户画像&quot;&gt;&lt;/a&gt;什么是用户画像&lt;/h2&gt;&lt;p&gt;用户画像是描述产品典型使用者的标签聚合，比如A用户：男，35岁，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《万万没想到》读书笔记</title>
    <link href="http://zikang.me/2016/10/18/20161018-%E3%80%8A%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zikang.me/2016/10/18/20161018-《万万没想到》读书笔记/</id>
    <published>2016-10-18T13:30:13.000Z</published>
    <updated>2017-04-04T10:09:56.705Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>自从看了老罗锤子发布会演示讯飞输入法之后，我也下载了下来，操作体验上还不错，准确度确实高；当时萌发出一个想法，用口述的方式来做读书笔记，这样一来能很好的加深印象，二来也能锻炼自己流畅表述的能力。这次就以《万万没想到》来尝试一下新的读书笔记记录方法。</p><p>《万万没想到》是在罗辑思维里推荐的一本书，主要是说怎样用理科生思维思考世界，我选了部分章节对我有用的章节做笔记：</p><ul><li><strong>具体思维</strong> ：作者先举了个例子，说有个实验给非洲儿童寄了两封信，其中一封用了具体的贫困人数来说明贫困状况以此呼吁大家捐款，而另一封则描述一位具体的小女孩是如何在贫困家庭中生活，实验结果显示描述小女孩的那封信收获的捐款要比用具体数字的信更多。作者解释因为生活模式的局限性导致大脑思考总是优先考虑具体的人和事。而具体思维做决策取决于人的价值观和对美的认知，而这被人们奉为常识。理工科思维往往是权衡利弊以及计算产出。在产品运营活动中可以多用图片和具体的案例来形象描绘奖励，规则等。</li><li><strong>确认偏误</strong> ：现在有很多媒体都是利用确认偏误来在某些争议的主题上站队，以此贩卖用户想要的信息；这里作者举了个全球变暖的例子，事实上全球变暖根本没有媒体报道的如此严重，看待问题要客观，尽量寻找信息的源头，并接收那些哪怕不符合自己观点的意见来避免回音室效应。</li><li><strong>负面情绪</strong>：作者举了一个损失厌恶的例子，说有一个实验给工人三十元奖励，只不过用了两种说法，第一种说法是如果完不成任务将少获得三十元，第二种说法是已经拿到奖励但是如果完不成任务将丢失这三十元；实验结果显示第二说法要比第一种的效果更好，说明人们更加在意负面情绪，丢失比得到要更严重。这也解释了为什么微博评论上的负面评论要比点赞等正面行为更加有效果。我们在做决策的时候要归于理性避免负面情绪带来的偏见。在产品或者运营的文案上可以借鉴损失厌恶来提升转化。</li><li><strong>数据逻辑</strong>：数据样本在比较少的时候容易出现不均匀的现象，这种现象称为小数定律；独立随机事件是没有规律的，这也解释了赌徒谬论。数据具有随机性和误差，对任何事物发生的原因做分析时要看到背后运气的成分。</li><li><strong>阴谋论</strong>：文中举了个例子，描述了一位女权主义者，但是在给她加上各种形容词标签使其更加合理之后，人们确更加相信加了描述之后的结果，但事实是标签越多，事情出现的概率就越小，而多数人抛开概率相信合理性。对于阴谋论我们只需要评估每一个描述的可能性就会发现这并不足以为信，阴谋论就是利用了人们思考的惰性，因为人为了方便理解更相信事物发生有它的目的性。我们在分析问题的时候要理性，要基于数据的基本逻辑。</li><li><strong>桥段</strong>：对电影/电视/小说/游戏里面的所有剧情进行分解总结，发现桥段就那么几十个来回用，类似于代码库。只有利用新的技术/科技才能创造出新的桥段，比如电影里显示屏的进化，穿越等等都是源于当时的先进科技和理念，写代码也类似，不能重复造工具造轮子。</li><li><strong>意志力</strong>：经科学分析后发现成功人士的普遍特质其实是意志力，做决策/冒险会消耗意志力，而补充能量/从小事开始养成习惯/自我监控/第三方监控都能提高意志力，美女的照片会减少意志力！</li><li><strong>优势劣势</strong>：优势和劣势是可以互相转换的，不应该一味追求加强某一方面的优势，而应该符合倒U曲线，在平台的初期投入能获得最多的回报，而在平台中期投入则不能获得更多的回报，到了后期投资回报反而是负的，这也说明了为什么警察数量和治安关系是处于一个临界点，警察多了反而治安更乱。维护游戏规则是强者的事，而弱者想逆袭能做的就是打破规则，另辟蹊径。</li><li><strong>一万小时理论</strong>：这个正确方法就是刻意练习，第一，只在学习区练习而不要在舒适区或者恐慌区练习说白了就是每天都有一个小目标，每天进步一点点。第二，把训练内容有针对性的分解成小块，对每一块重复练习加深印象说白了就是反复练习套路，律师看案例，程序员学算法。第三，在整个练习过程种随时能够获得有效的反馈，可以通过一些测验的方式，这也正是老师的作用，写代码为什么容易自学，就是因为能够很快的知道运算是否正确。第四，练习时大脑的注意力必须高度集中，必须一个人练习，应该摒弃寓教于乐比如纪录片/电影/游戏等方式。适当的奖励也是有必要的，但是兴趣在其中起的作用应该时最明显的。</li><li><strong>想象力</strong>：初级的想象力是把两个不相干的事物荒诞地结合在一起，而高级的想象力却是基于知识精心设计出来的，比如指环王/魔兽世界等知名大作都是具有完整的世界观和极小的细节，这些细节大多都是经得起得推敲的，这也能看出民科和正规科学的区别。</li><li><strong>读书笔记</strong>：读书笔记应该包括四方面内容，第一，清晰地表现每一章的逻辑；第二，带走书中的所有亮点；第三，有大量自己的看法和心得；第四，发现这本书和自己以前读过书或文章之间的联系。</li><li><strong>过度自信</strong>：过度自信是成功的优良品质，因为过度自信会高估自己的能力水平，从而会选择干一些比自己水平高的事情/采取更冒险的策略，因为高水平的事情/冒险往往会获得更多的利益。</li><li><strong>社交多样化</strong>：社交多样化的弱联系理论说明人脉的关键是信息的传递，只有社交多样化才能获得你所不知道的信息，而总是和自己最熟的朋友在一起圈子就被固定死了，不论是工作还是创业找那些不常联系的朋友可能比常联系的朋友效果要更好。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;自从看了老罗锤子发布会演示讯飞输入法之后，我也下载了下来，操作体验上还不错，准确度确实高；当时萌发出一个想法，用口述的方式来做读书笔记，这样一来能很好的加深印象，二来也能锻炼自己流畅表述的能力。这次就以《万万没想到》来尝试一下新的读书笔记
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《引爆点》读书笔记</title>
    <link href="http://zikang.me/2016/09/15/20160915-%E3%80%8A%E5%BC%95%E7%88%86%E7%82%B9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zikang.me/2016/09/15/20160915-《引爆点》读书笔记/</id>
    <published>2016-09-15T07:15:57.000Z</published>
    <updated>2017-04-04T10:09:33.047Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>《引爆点》是一本讲述“流行”的好书，里面的观点可以合理解释生活中流行是如何发起，最令我印象深刻的就是青少年抽烟流行潮以及如何科学分析和解决青少年吸烟的问题。作者认为流行潮的发起遵循三个法则：个别人物法则/附着力因素法则/环境威力法则，这三个法则相辅相成，几乎任何流行都可以通过这三个法则去理解。</p><h2 id="个别人物法则：联系员-内行-推销员"><a href="#个别人物法则：联系员-内行-推销员" class="headerlink" title="个别人物法则：联系员/内行/推销员"></a>个别人物法则：联系员/内行/推销员</h2><p>他们都是信息传播者，也可以是一个人多种身份，任何一种传染病/电影/情报都可能因为与其中某个特别人物关联而变得极富传染力。</p><ul><li><p><strong>联系员</strong>：拥有强大社交天赋，结识的人非常多，涉足的领域也非常多；生活中的社交达人都属于联系员，他们能和每个人都成为朋友，是流行传播的重要人物，他们是社交网络中的KOL</p></li><li><p><strong>内行</strong>：掌握最多且不为人知的信息，善于通过分享信息帮助别人来获得满足感；细分领域的专家，熟知超市各种打折信息的大妈们都是内行</p></li><li><p><strong>推销员</strong>：交谈时有超强的感染力，能轻易说服别人；天生拥有发送情绪的能力，如金牌销售，公关</p><p>​</p></li></ul><h2 id="附着力因素法则：在适当情况下，信息总是存在一种包装方法，使其难以抗拒"><a href="#附着力因素法则：在适当情况下，信息总是存在一种包装方法，使其难以抗拒" class="headerlink" title="附着力因素法则：在适当情况下，信息总是存在一种包装方法，使其难以抗拒"></a>附着力因素法则：在适当情况下，信息总是存在一种包装方法，使其难以抗拒</h2><p>心理学家曾做过实验，给学生发三种版本的破伤风疫苗宣传的小册子，一种是内容夸张配有彩色图片和案例的“高恐惧”版本，另一种则是没有危险语气描述的“低恐惧”版本，而第三种版本只是增加了学校医院地图和注射时间；结果发现“高恐惧”和“低恐惧”版本的宣传作用并没有多大区别，“高恐惧”版本虽然说服力大，但是却和目的并不相关，而第三种加地图的版本却要比前两种的效果好30%，学生即便不看夸张的图片，心里也明白破伤风的危害，也自己知道该怎么做，而且作为高年级学生，他们自然已经知道医院的位置，换句话说，发起注射破伤风疫苗流行潮所需要的并不是普天盖地的新信息和额外信息，而是让学生们知道如何把打破伤风一事合理地安排到自己的生活里；增加一张地图和注射时间安排后，就把小册子从一堂抽象的健康危害课变成了一个针对个人健康的实际建议。一旦建议变得实际且符合个人需要，它就会变得令人难忘。</p><h2 id="环境威力法则①：流行潮发起的条件-时间-地点"><a href="#环境威力法则①：流行潮发起的条件-时间-地点" class="headerlink" title="环境威力法则①：流行潮发起的条件/时间/地点"></a>环境威力法则①：流行潮发起的条件/时间/地点</h2><p>一个人的行为很大程度上取决于环境的影响；20世纪90年代初的纽约，平均每年的谋杀案超过2000起，严重犯罪活动超过600000起，暴力和犯罪成为纽约街头的潮流，其中“破窗理论”可以很好的解释这种犯罪潮兴起的原因，该理论是有犯罪学家詹姆斯·Q·威尔逊和乔治克林提出，他们认为犯罪是秩序混乱的必然结果，如果一个窗户被打破了，过了很久也没有人来把它修好，行人就会以此推断，这是个没人管理的地方。很快，就会有更多的窗户被打破，类似在公共场所乱涂乱画，秩序混乱，强行乞讨这些较小的问题都和“破窗”效应一样，容易引起更严重的犯罪；强盗和劫匪不管是即兴作案还是职业惯犯，都相信如果他们选在居民普遍惧怕犯罪分子的街道来作案，那么他们就不容易被发现，甚至不会被认出来。如果一个社区无法制止乞丐对路人的骚扰，小偷就会据此推断，这里不太可能有警察来防止潜在的劫犯，或者当真的有罪犯行凶或抢劫时，也不会有警察来干预。犯罪潮是可以传染的，就像时尚潮流一样，但这种流行潮的引爆点不是某个人，而是某些物质，比如公共场所的涂鸦。20世纪90年代中期，政府开始集中清理街道环境，整治各类违反秩序的行为，犯罪率从那时开始急速下降。</p><h2 id="环境威力法则②：最有效的群体规模是150人"><a href="#环境威力法则②：最有效的群体规模是150人" class="headerlink" title="环境威力法则②：最有效的群体规模是150人"></a>环境威力法则②：最有效的群体规模是150人</h2><p>认知心理学有一个概念“通道容量”指我们的大脑在接受某些信息时所具有的记忆空间，比如电话号码7位数就是人脑的一种通道容量；除了信息加工的智力通道容量，还可以延伸到情感通道容量，而经科学计算人能保持的社会关系在150人左右（你能够知道他们都是谁，和你是一种什么程度的关系，或者说，你和这些人交往程度达到了如果你未被邀请却恰好碰上他们在一起喝酒，但你不会因此感到难堪的程度）比如军事上基本作战的连级规模始终在150人左右。戈尔公司的每个厂的员工始终都保持在150人的规模，员工在公司都是平级，戈尔公司具有高效的组织性互动记忆，员工描述他在公司不仅仅知道某个人，还能知道他的技术，能力和为人，在工作种遇到任何问题都可以找到最适合解决的人，因此工作效率非常高，在家庭关系种这种互动记忆是构成亲密关系的一部分且非常明显；比如男朋友会修电脑，那自己就不需要知道如何去修理，让男朋友修就行了，女朋友对小孩的智力开发特别擅长，那自己也不必去刻意学习了，这种互相依赖也是使离婚变得痛苦的原因。大规模的流行潮是由许多小的流行潮推动的，道理很明显，去电影院看电影的人都知道，某个电影好不好，从涌入电影院的观众数量可窥见一斑；无论是喜剧片还是惊险片，都只在人流如潮的电影院才显得更具有戏剧意味/更激动人心。心理学家的说法与此非常相似；如果让人们在人群种做推理或决定，他们得到的结论与他们独处时给出的回答截然不同。一旦我们成为群体种的一员，我们都容易受到来自身边众人的压力/社会规范和其他形式的影响，正是这种至关重要的影响裹挟者我们加入到某个潮流种去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;《引爆点》是一本讲述“流行”的好书，里面的观点可以合理解释生活中流行是如何发起，最令我印象深刻的就是青少年抽烟流行潮以及如何科学分析和解决青少年吸烟的问题。作者认为流行潮的发起遵循三个法则：个别人物法则/附着力因素法则/环境威力法则，这三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《爆款》读书笔记</title>
    <link href="http://zikang.me/2016/08/05/20160805-%E3%80%8A%E7%88%86%E6%AC%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zikang.me/2016/08/05/20160805-《爆款》读书笔记/</id>
    <published>2016-08-05T12:41:13.000Z</published>
    <updated>2017-04-04T10:09:11.461Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>刚拿到这本书的时候，第一反应是讲淘宝的爆款，后来发现这本书的格局要更大，从泛娱乐行业解释爆款。书上的内容多是例子，读起来要轻松很多。可惜的是本书并没有对如何打造爆款做深入的剖析，读之前可以针对个人情况结合我总结的读书笔记来决定如何读。整理了下本书的提纲，我只说具体的某一部分。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173913767.jpg" alt="mark"></p><h2 id="投注爆款"><a href="#投注爆款" class="headerlink" title="投注爆款"></a>投注爆款</h2><p>何为爆款，我认为是一种符号，一种代表某领域内最知名的群体的符号。在国内，最近几年各种IP（知识产权）的争夺层出不穷，一本畅销小说，可以轻易的改编成电视剧、电影，再开发同款的游戏、周边。这一系列的产出带来的价值远比当初写小说的稿酬要多的多。书中举了个例子：漫威影视，一家靠漫画出身的公司，凭借着旗下的超级英雄漫画人物为主角的电影，在市场上赚的盆满钵满，从最开始的《复仇者联盟》拿下13亿票房到后面的《钢铁侠》、《美国队长》无一不是横扫各大影院。再说为什么这些爆款能给人带来巨大收益，其中一个原因便是广告效率的提升，知名电影的宣传不需要增加额外的营销成本，看过《复仇者联盟》自然知道《美国队长》讲的是什么。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173928247.jpg" alt="mark"></p><h2 id="如何打造爆款"><a href="#如何打造爆款" class="headerlink" title="如何打造爆款"></a>如何打造爆款</h2><p>任何爆款其本质都是优秀的，顶级的明星比如C罗，他的球技自然也是联盟里的头部；知名的演员，必然有超凡的演技；当然，这个现象在体育界比较明显，因为大家都喜欢赢家，这也是为什么皇马花重金打造“银河战舰”。有了好的产品已经成功了一半，剩下的当然是靠大规模的发行来抢占主流市场，这里提一个优势积累理论，意思是说消费者在中后期购买产品时，如果他知道当时的主流程度，那么他的最终消费无非是对初期主流市场结果的再次放大。就好比我们逛京东，初次筛选总是按销量排序，因为这会给我们一种思维定势，认为大家都买了肯定没错，如果真要坑了那么也会有一大堆人一块被坑。这就产品给了消费者值得信任的信号。还有一点也至关重要，就是针对自己的产品请符合气质的超级明星代言，这么做有什么好处呢？超级明星有着巨量粉丝，而这些粉丝所带来的消费和传播是不可忽视的，乍看成本很高，其实正确的利用明星效应带来的收益将会远超成本。</p><h2 id="数字技术和爆款"><a href="#数字技术和爆款" class="headerlink" title="数字技术和爆款"></a>数字技术和爆款</h2><p>这也是我重点想说的，毕竟和自己的行业关系较大，这一块必须得先了解一下两个重要且看似矛盾的理论：长尾理论和二八定律（本书的爆款策略），长尾理论在互联网兴起的时候很受欢迎，意思是说在互联网行业，制作、传播、维护甚至是盗版的成本都非常低，致使大量的用户和产品进驻互联网，甚至有取代传统行业的趋势，比如亚马逊，亚马逊的图书销售有大部分集中在冷门的书籍上，而放在以前，书架的位置可是有限的，那些销量不佳的书籍很快就会被新书取代。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173938582.jpg" alt="mark"></p><p>在线视频领域的领头羊youtube起家的时候也是靠着互联网低成本的优势吸引巨量用户进入。在10年前长尾理论在各个互联网领域都得到了认同，而逐渐往后，长尾理论也渐渐的失去了圣经的效果，越来越多的事实证明二八定律才是正确的，再拿youtube说，youtube近些年一直在打造他的原创频道，因为公司的高管发现，播放量大的视频还是集中在某一部分UP主里。再说说数字音乐，2011年全球数字音乐销量中，1%的单曲获得了80%的下载量，这比传统的二八定律还要更加严重。可见爆款策略的英明。反观国内，优酷、土豆、爱奇艺争相独播各种热门影视剧，不知道多少人为了看一部热门剧而去购买会员。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173952615.jpg" alt="mark"></p><h2 id="谈谈心得"><a href="#谈谈心得" class="headerlink" title="谈谈心得"></a>谈谈心得</h2><p>看了本书扎堆的例子，我觉得长尾理论更加适合用在某个领域初期，那时候获得一个用户的成本要低很多；而爆款策略更适合在某个领域的后期，设施都已完善，用户更加关注的反而是其内容，这也是为什么papi酱、咪蒙等内容博主火热的原因。再有，长尾理论更加适合用来衡量销量，二八定律适合衡量利润；这也就合理的解释了书中的例子。我认为未来的互联网行业技术、产品体验都已成熟，而市场会更加看重内容，赢者通吃的现象将也会更加明显。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;刚拿到这本书的时候，第一反应是讲淘宝的爆款，后来发现这本书的格局要更大，从泛娱乐行业解释爆款。书上的内容多是例子，读起来要轻松很多。可惜的是本书并没有对如何打造爆款做深入的剖析，读之前可以针对个人情况结合我总结的读书笔记来决定如何读。整理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解密增长黑客</title>
    <link href="http://zikang.me/2016/07/14/20160714-%E8%A7%A3%E5%AF%86%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    <id>http://zikang.me/2016/07/14/20160714-解密增长黑客/</id>
    <published>2016-07-14T11:57:20.000Z</published>
    <updated>2017-04-04T10:08:52.475Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>有幸拜读了范冰的《增长黑客》，这本书中包含大量的干货和案例，是产品运营推广的优秀工具书。内容较多，子康对书中的知识框架进行了整理，相当于读书笔记吧。</p><p>“增长黑客”乍一看以为是黑别人电脑的技术大牛，但是仔细看了介绍才知道“增长黑客”是一种新兴的职业，具体的说，这是一群以数据驱动营销、以市场指导产品，通过技术手段转化贯彻增长目标的人。可见技术是“增长黑客”的核心技能，运营和产品的思维是“增长黑客”的能力加持，利用各种方法优化产品在获取用户、激发活跃、提高留存、增加收入和传播推荐中的表现则是“增长黑客”的目标。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/172816751.png" alt="mark"></p><p>Growth Hacker的前提是要有一个好产品，它是拯救不了一个烂产品的。</p><p>一个产品不满足PMF也只是产品经理自己的YY罢了，创业初期打造一款产品最重要的是快，用最快的时间最简单的功能去验证市场，这便是书中提到的打造“最小化可行产品”，而这个“最小化可行产品”必须具备除了基本功能外的模块包括：反馈渠道、官方公告以及自动升级。这些模块是为了能更好的优化产品和快速迭代。书中Sendwithus的案例很是有趣，这款电子邮件营销公司在成立初期并没有做出产品，而是用了几个前端页面伪装成产品给用户使用，当用户点击想要的功能按钮时便会提示用户申请成为早期服务的测试资格，而Sendwithus通过对用户的点击动作来分析哪些功能需要哪些是不需要的，而且还培养了一批期待新产品的种子用户，可谓一箭双雕。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/172826382.png" alt="mark"></p><p>Growth Hacker 如何获取用户呢，首页得从核心用户开始，找准产品对应的种子用户。再通过各种手段去推广拉新用户，看见数据抓取的方法让我想到另一个案例：旅行推，这是一个旅行类的产品，产品的负责人通过在新浪微博抓取关于旅行的微博，并通过算法过滤掉无用的数据，再对这些微博用户发私信，但是人工太慢，负责人又发明了一套自动对话的机制。最终只有一两个人识破了这个机器人谜题，其他人受到了狡猾的蒙蔽……于是，30万目标用户+不知厌烦的机器人，完成了产品的冷启动。多么典型的Growth Hacker！</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/172842733.jpg" alt="mark"></p><p>有了种子用户，又该如何去激发活跃呢？而在这章，重点之一便是A/B测试、这是在有多种备选方案时的利器，通过对不同的用户分发不同的版本，针对核心数据做分析，就可以得出哪版方案是有利的。降低活跃用户门槛也是很重要的方法，QQ音乐巧将歌词和封面组合形成了新的锁屏歌词功能，wifi万能钥匙更是利用光学字符识别对ios的热点页面解析，绕过了应用不能直接读取ios的wifi列表的阻碍。不得不说：高！</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/172852253.jpg" alt="mark"></p><p>留住已有的用户胜果拓展新的用户，可见留住用户对于产品的重要性。书中总结用户流失的原因有5点：</p><ol><li>存在程序漏洞</li><li>用户被频繁骚扰</li><li>话题产品的热度消退</li><li>有更好的替代品</li><li>其他因素（游戏通关、需求不再存在、产品生命周期终结等等）</li></ol><p>如何提高留存，书中给了很多方法：优化产品性能，提供有损服务、社交维系和社交解绑、各种推送通知。而其中提供有损服务是个很有启发的方法，很多时候，我们认为提供最好的服务用户就能买单了，事实上并非如此，Facebook工程师们去了非洲之后发现那里用户的使用情况却远没有那么简单，非洲的用户由于网不好，流量少，手机配置不高导致很多用户使用 Facebook并不能有良好体验，工程师便针对这一情况做了一系列优化，包括：加载分辨率低的图片，在点击图片时再读取分辨率高的图片。开机启动时只加载必要功能，采用更小的图片格式。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/172953982.png" alt="mark"></p><p>在社交维系这一节，作者在阐述如何利用社交关系留住用户后，又提到了same这款产品。same算是孤独社交，没有任何传统社交产品的关注／连接机制，反而让人摆脱了微博的等级分化和朋友圈的社交压力，获得了不少用户的芳心，这就是所谓的“社交解绑”。</p><p>有了足够的用户之后，Growth Hacker们就得思考如何去挖掘用户的价值了，毕竟产品始终是要盈利的。收获取收入，首当其冲便是免费模式，像当初玩的网络游戏征途，一听说免费便立马下载，玩到后期才发现“免费”游戏一点也不免费，但你发现的时候已经玩到很高级了，要退出也是不舍啊。免费模式Freemium策略便是基于经典的“二八定律”即产品中有一小部分对价格不敏感的高端用户，愿意支付额外费用来换取全部的高级功能，而这部分费用成为服务提供商的大部分收入来源，凭借这块收入负担起那些免费用户的服务成本。</p><p>另一个经典案例便是腾讯非法QQ会员，腾讯针对那些购买非法会员的用户不但没有封号等惩罚，相反，确实给它们提供了八折的会员优惠。正是这种变惩为奖的策略给腾讯带来了更多的QQ会员付费用户。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173003470.jpg" alt="mark"></p><p>最后的讲的是Growth Hacker如何利用病毒营销实现用户的爆发增长，病毒营销的两大核心指标：K因子 =感染率*转化率、以及病毒循环周期，k因子是传播效果的提现，自然是越高越好，而病毒循环周期则是传播到转化的周期，越短越好。常见的营销方式便是利用社交网络针对热点借势营销，或者是结合自己的产品定位设计新的玩法、引发传播是一门高深的学问，把握好病毒传播中心用户的心理是重中之重，利用一些人性的弱点，引发共鸣就有可能打造下一个引爆点。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/173011741.jpg" alt="mark"></p><p>当然了，不要过分营销，为了增长不惜一切手段的无下限营销最终也只会是引火烧身。</p><p>本文只是对《增长黑客》做的简单笔记，本书理论知识并不是很多，但是里面的案例足够引发你对产品和运营的思考，如果你想深入学习，这本书绝对值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;有幸拜读了范冰的《增长黑客》，这本书中包含大量的干货和案例，是产品运营推广的优秀工具书。内容较多，子康对书中的知识框架进行了整理，相当于读书笔记吧。&lt;/p&gt;
&lt;p&gt;“增长黑客”乍一看以为是黑别人电脑的技术大牛，但是仔细看了介绍才知道“增长
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析微信朋友圈广告</title>
    <link href="http://zikang.me/2016/04/13/20160413-%E6%B5%85%E6%9E%90%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B9%BF%E5%91%8A/"/>
    <id>http://zikang.me/2016/04/13/20160413-浅析微信朋友圈广告/</id>
    <published>2016-04-13T05:20:24.000Z</published>
    <updated>2017-04-04T10:08:30.065Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="朋友圈广告的背景"><a href="#朋友圈广告的背景" class="headerlink" title="朋友圈广告的背景"></a>朋友圈广告的背景</h2><p>据统计，至2014年底，微信用户数量达11.2亿人，每月活跃用户4.4亿，而在日常使用中，76.4%的用户会使用朋友圈来查看朋友动态或进行分享，也就是说，每月有3.4亿活跃用户在刷朋友圈，可见微信的朋友圈广告市场非常庞大。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163125184.png" alt="mark"></p><p>朋友圈广告的来历微信朋友圈并不是像微博那样的“广场围观式”社交平台，而是一个基于天然的通讯录联系人形成的“强关系”的“熟人”社交平台。“熟人”社交并非没有先例，国外社交网站Facebook也用过相同的做法。相比于国外成熟的法治社会，中国人还是更愿意相信熟人，微信依靠朋友圈做推广，其作用要大于Facebook和Twitter等国外网站。人们会觉得收到来自熟人的消息，是一则已经进行过一层过滤的广告，可信度比较大。</p><p>微信朋友圈广告采用的是Feed信息流广告，与弹出式广告不同，为了避免打扰到用户的体验，信息流广告试图通过收集到的用户信息、历史记录、社交关系和地理位置进行有针对性的投放，力求与用户“想要的”一致。形式类似于朋友的原创内容，基于对微信用户画像进行定向的同时，再通过实时社交混排算法，依托关系链进行互动传播。信息流广告第一次被大面积应用，是在国外社交网站Twitter上。2011年7月，Twitter推出了Prompted Tweets，广告以1/10到1/20的频率出现在普通推文当中，展示形式与普通推文类似，加上了“promoted”字眼。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163201599.jpg" alt="mark"></p><p>随后，Facebook也开始进行信息流广告的投放。在2012年上市之前，Facebook推出了为移动设备设计的广告平台，在news-feed信息流中植入广告。Facebook内部采用一个指标“Engagement”来评价一个内容是否会吸引当前用户，它决定一个内容是否出现在用户的news-feed中，以及出现在什么位置。Engagement这个指数是通过以下几个互动行为的加权公式算出的：喜欢、分享、点击、评论，至于这四个维度经过什么样的加权公式来计算，这是Facebook内部最大的秘密，而且这个加权公式是动态的，随时可能调整。</p><p>目前，Facebook在全球有13.5亿用户，其中移动用户占11.2亿，在2014年第三季度，移动端广告为Facebook带来的收入是19.5亿美元，占整体收入的66%，而信息流广告已成为了Facebook最大的收入来源和主要的盈利模式。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163214784.png" alt="mark"></p><h3 id="朋友圈广告的特点"><a href="#朋友圈广告的特点" class="headerlink" title="朋友圈广告的特点"></a>朋友圈广告的特点</h3><p>与Facebook和Twitter的信息流广告类似，微信的朋友圈广告也有如下的特点：</p><ol><li>微信朋友圈广告采用头像加名称的表现方式和朋友圈信息外观基本一致，点击后可以关注。</li><li>广告右上角有一个推广标签，点击标签可以选择“不感兴趣”从而关闭此广告。</li><li>广告中有详情链接，点击链接可以进入广告页面，但没有转发功能。</li><li>具有互动性，用户可以点赞也可以随意发表评论；互动越多，广告对用户好友展示的概率越大，如果没有互动，6个小时后广告会自动消失。</li><li>广告的投放有效时间为7天，对于单个用户来说，每48小时内只会看到一则广告。</li></ol><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163227087.png" alt="mark"></p><h3 id="朋友圈广告的优劣势"><a href="#朋友圈广告的优劣势" class="headerlink" title="朋友圈广告的优劣势"></a>朋友圈广告的优劣势</h3><p>朋友圈广告的优势在于“熟人社交”所带来的信任感。好友在朋友圈广告里点赞或者评论，用户都可以看到。而好友的点赞或者评论很有可能会影响用户的购买决策，如果朋友圈大部分好友都给予了广告评论，那么用户看到朋友圈这则广告的概率就会更高，通过这种方式投放广告，拉近了广告主与受众的心理距离，能够达到很好的传播效果。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163239373.png" alt="mark"></p><p>但是随着朋友圈的扩张，陌生的面孔是逐渐增多的，朋友圈成员之间原本的强联系正渐渐变弱，疏离感加强，传播效果不免会打折扣。从首批广告的传播效果来看，人们不知不觉已经成为了广告主口碑营销的工具。然而，如果微信未来的一些做法引起一部分用户的反感，一旦社交平台上的广告没能引发大规模的群体参与热情，或者在内容沟通创意上没有找到足够引起共鸣的点，新鲜一过大家也就审美疲劳回归常态。这类广告形式最适宜那些想要快速建立品牌关注度的广告主，以付费式的社交媒体操作对于品牌有极大的助力。微信信息流广告给品牌提供了更多付费社交的广告机会，这对于增强品牌知名度和传播高质量内容来说是非常有利的途径。</p><p>此外，能否最大程度地来精准投放也是摆在微信面前的课题。有效的信息流广告要能为消费者提供真正需要而且不必过多去考虑并选择的产品。显然，这也许会发生在将来，但还不是现在。从微信朋友圈广告公布的定向标准来看，涵盖用户的年龄、性别、地域、操作系统、网络状况和用户兴趣，这些标准与新浪微博和人人网的定向标准并无太大差异。虽然目前微信的用户总数已经达到可提供海量的累积数据，但微信仍然尚未对庞大数据进行系统性的标签化管理，故目前还无法达到真正精准的投放，这也解释了为何第一批微信广告引来了用户激烈的讨论，因为很多用户收到的信息流广告与品牌锁定用户在人群归属上是有一定程度的落差的。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/163248745.png" alt="mark"></p><p>不管怎么说，微信朋友圈广告市场是很庞大的，除了腾讯自身，做为普通的广告主和广告公司如何利用朋友圈做精准营销也是值得仔细研究的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;朋友圈广告的背景&quot;&gt;&lt;a href=&quot;#朋友圈广告的背景&quot; class=&quot;headerlink&quot; title=&quot;朋友圈广告的背景&quot;&gt;&lt;/a&gt;朋友圈广告的背景&lt;/h2&gt;&lt;p&gt;据统计，至2014年底，微信用户数量达11.2亿人，每月
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>O2O创业模版，家政行业转型实例</title>
    <link href="http://zikang.me/2016/03/15/20160315-O2O%E5%88%9B%E4%B8%9A%E6%A8%A1%E7%89%88%EF%BC%8C%E5%AE%B6%E6%94%BF%E8%A1%8C%E4%B8%9A%E8%BD%AC%E5%9E%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>http://zikang.me/2016/03/15/20160315-O2O创业模版，家政行业转型实例/</id>
    <published>2016-03-15T12:41:13.000Z</published>
    <updated>2017-04-04T10:07:46.562Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="传统家政行业经营模式"><a href="#传统家政行业经营模式" class="headerlink" title="传统家政行业经营模式"></a>传统家政行业经营模式</h2><p>国内家政服务企业的运营模式主要集中表现为三类组织形式，即中介型家政服务企业、员工制家政服务企业和会员制家政服务企业。中介型的家政服务企业比较常见，运作模式存在历史也比较长；员工制家政服务企业则属于精品型家政服务组织该运作模式，该企业的结构管理较为规范，在团队建设方面少而精良，企业组建投入少、风险小无需大规模、大设施即可获得高收益。会员制家政服务企业是介于中介型家政服务组织和员工制家政服务企业两种模式之间的一种经营管理模式。根据不同经济收入的雇主对家政服务员的需求利用市场经济手段对雇主的不同服务需求而采取不同的服务、管理方法。</p><p>O2O模式兴起O2O主要有两种解释片是Online to Offline（线上到线下）。典型应用场景有用户在线上购买或预定服务然后再到线下商户实地享受服务，或者用户在线上购买或预定商品然后再到线下的实体店取货或体验。二是Offline to Online（线下到线上）。应用场景有：用户通过线下实体店体验并选好商品然后通过线上下单来预定商品。目前市场上比较火热的像58到家、阿姨帮、e家洁、小马管家、云家政等等都是基于O2O模式发展的，用户基于位置在平台上下单，服务人员上门服务，之后在线完成支付和点评，从而形成了交易的闭环。</p><h2 id="O2O家政的优势分析"><a href="#O2O家政的优势分析" class="headerlink" title="O2O家政的优势分析"></a>O2O家政的优势分析</h2><p>1、顾客评价公开O2O家政公司以每名员工为单位，每次服务之后顾客都会给予其雇佣的员工以相应的评价，这些评价就跟在淘宝上购物是一样的，对所有顾客公开。这样顾客便可以了解每个员工的优缺点，进而选择最适合自己的员工。</p><p>2、价格透明传统家政公司的顾客只能通过家政公司的推荐，了解几个员工的价格，无法了解所有员工的价格，无法进行比较选择。而O2O家政公司公开所有服务人员的雇佣价格，给顾客以最大的自主选择权和知情权。</p><p>3、先工作，后付款O2O家政公司预约不需缴纳任何费用，员工工资在服务期满一个月，或服务结束后，由雇主当面直接付给员工。</p><p>4、不收中介费传统家政公司的在员工工资的基础上，抬高价格，赚取中介费，以维持公司的运营。而O2O家政公司由于公司为网络经营模式，所以运营成本很低。而且工资结算是由顾客直接付给员工，公司并不经手，所以免去了中介费，使顾客得到更大的实惠。</p><p><img src="http://om2zpy4xm.bkt.clouddn.com/blog/20170404/165858524.jpg" alt="mark"></p><h2 id="O2O家政的劣势分析"><a href="#O2O家政的劣势分析" class="headerlink" title="O2O家政的劣势分析"></a>O2O家政的劣势分析</h2><p>1、社会诚信体系不完善家政服务不同其他传统服务，是入室服务。住宅被法律视为个人隐私范畴，未经房屋主人的同意是不允许外人随意进入，不论在古代还是当今，私闯民宅都是违法的事。因此这个行业除了要求服务者的服务技能良好，还需要建立雇佣双方的信任关系。然而不论哪个行业都会存在因为私利而出现有损行业发展的恶意行径，包括家政行业尤为谨慎。在社会诚信体系尚不完善的情况下，陌生人之间的信任关系显得尤为脆弱。简单的把家政服务员的信息罗列到网上是不能够解决雇佣双方的信任屏障，尤其对居家保姆这样的特殊职业，雇佣双方更是一个相互选择的过程。雇主希望找到一个放心又能干的阿姨，阿姨则希望能碰到一个慈善又懂得体谅的雇主。因此在诚信体系尚不完善的大环境下，在没有更多可以将双方信息透明化时，双方面谈，消除顾虑是必经的流程。但是短时间的面谈并不能完全取得彼此信任，如果在工作过程中出现问题，雇佣双方仍然需要继续建立信任或者面临重新选择，这是一个高成本的试错过程。</p><p>2、行业标准化推行难度大家政行业目前遇到的另一个问题是服务不够标准化，不同企业、不同家政服务员提供的服务质量参差不齐，使得这一行业认可度偏低，用户没有第三方权威渠道获取家政服务员在服务技能上拥有令人信得过的成绩。因此一些家政企业正在试图着力打造自己的品牌，强化自有培训组织建设，希望能够树立行业典范。但目前家政行业还没有出现国家级家政标准化示范企业，因此这会产生在实际执行标准化服务推广过程中出现没有统一规范的现象；其次家政服务员普遍素质不高，接受程度低，这些人的目标不是严格要求自己践行标准化服务，而更多是出于用户的评价影响自己后续接单，实际用户自己也不知道所谓标准化到底是怎样一个内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于互联网思维的O2O提供的是用户获得服务更畅通的一种渠道，互联网简化了传统的信息传递路径，同时可通过信息化工具对客户群体进行有效的沟通与客户关系管理。信息化提高了家政服务的透明度，迫使服务更加透明化、标准化、品牌化，很大程度上加速了家政服务行业标准化与职业化的进度。客户通过家政企业泛布在线上各个渠道的精准信息，快速获得服务，将家政O2O引人C2C的对话与消费模式，真正从渠道上“消灭中介”，由家政O2O企业提供的标准化培训与服务跟踪及评价体系，改善之前行业散乱的形象。</p><p>O2O的线上服务注重去中心化、去平台化、大数据化、生态圈化，但是家政服务终究还是要落实到具体的人对人去完成，因此，要想利用好家政O2O这把利器，必须清晰地认识到并解决家政符文过程中的标准化等若干问题。家政O2O的关键问题在于线下服务标准化和服务质量控制的问题，标准化、规模化、品牌化和体系化既是国内家政行业的发展的主题诉求，更是家政O2O的第一道核心保障。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;传统家政行业经营模式&quot;&gt;&lt;a href=&quot;#传统家政行业经营模式&quot; class=&quot;headerlink&quot; title=&quot;传统家政行业经营模式&quot;&gt;&lt;/a&gt;传统家政行业经营模式&lt;/h2&gt;&lt;p&gt;国内家政服务企业的运营模式主要集中表现为
      
    
    </summary>
    
    
  </entry>
  
</feed>
